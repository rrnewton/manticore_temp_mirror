\documentclass[11pt]{article}

\setlength{\textwidth}{6in}
\setlength{\oddsidemargin}{0.25in}
\setlength{\textheight}{9.0in}
\setlength{\topmargin}{-0.75in}

\input{../common/common-defs}
\usepackage{graphicx}
\usepackage{listings}

\newenvironment{CCODE}
{\lstset{language=C}
\lstset{columns=flexible}
  \lstset{commentstyle=\textit}}

\title{VProc protocol}
\author{The Manticore Group}
\date{Draft of \today}

\begin{document}
\maketitle

\section{Overview}
This document describes the protocol for managing vprocs.

\section{Signaling and sleeping}\label{sec:signaling-and-sleeping}
This section presents two alternative signaling protocols for vprocs.
Both protocols have their advantages, and here we describe both to evaluate
which is most appropriate for the Manticore implementation.
The rest of this section is structured as follows.
In this secion we outline the interface and semantics of the protocol.
Section \ref{sec:protocol1} describes the first protocol, and section
\ref{sec:protocol2} describes the second protocol.
Then \secref{sec:evaluation} compares the protocols.

\paragraph{Signals}
A signal is a fiber paired with fiber-local storage.
To handle a signal, a vproc initializes the fiber-local storage and runs the fiber to completion.

\paragraph{Landing pad}
The \emph{landing pad} is a lock-free linked list of incoming signals.
Each vproc owns a landing pad, and has access to all the other remote landing pads.
The landing pad supports two operations.
\begin{enumerate}
  \item Push a message on a remote landing pad.
  \item Pop all messages from the local landing pad.
\end{enumerate}

\paragraph{Sleeping}
When there is nothing to do, a vproc enters a temporary sleeping state, which lasts until either a
signal arrives on the vproc's landing pad or a global garbage collection is initiated by some other
vproc.
We avoid busy waiting by waiting on a condition variable provided by the Pthreads
library.
Unfortunately, the fact that the landing pad is a lock-free data structure causes
a problem:
signals might arrive after the vproc has checked the landing pad but before the vproc has
begun waiting on the condition variable.
Thus, there is a potential race condition that would allow the vproc to wait indefinitely,
even when work becomes available.
Our protocols must address this race condition by using some additional
synchronization.

\paragraph{Vproc operations}
Below are the operations that the vproc protocol must provide.
\begin{itemize}
  \item Place a signal on the landing pad of a remote vproc.
    \footnote{Note that this operation has undefined behavior when applied to the host vproc.}
    \begin{CCODE}
      \begin{lstlisting}
      void Send (VProc_t *vp, Fiber_t *k, Value_t *fls);
    \end{lstlisting}
    \end{CCODE}
  \item Place a high-priority signal on the landing pad of a remote vproc. Unlike Send, Interrupt
    forces the vproc to stop and handle the incoming signal. The vproc must handle the signal
    within a constant number of computational steps.
    \footnote{Note that this operation has undefined behavior when applied to the host vproc.}
    \begin{CCODE}
      \begin{lstlisting}
      void Interrupt (VProc_t *vp, Fiber_t *k, Value_t *fls);
    \end{lstlisting}
    \end{CCODE}
  \item Receive signals from the host vproc's landing pad. 
    \footnote{Note that this operation has undefined behavior when applied to a remote vproc.}
    \begin{CCODE}
    \begin{lstlisting}
      Value_t Recv (VProc_t *host);
        \end{lstlisting}
    \end{CCODE}
  \item Put the host vproc to sleep until its landing pad becomes nonempty.
    \footnote{Note that this operation has undefined behavior when applied to a remote vproc.}
    \begin{CCODE}
    \begin{lstlisting}
      void Sleep (VProc_t *host);
        \end{lstlisting}
    \end{CCODE}
\end{itemize}

We choose to minimize the synchronization overhead of Send even at the expense of
increasing the overhead of Sleep.
The rationale is that, in the common case, the Sleep operation affects idle vprocs, whereas
the Send function affects working vprocs.

\paragraph{Vproc components}
The vproc structure (\figref{fig:vproc-structure}) contains a few components that are relevant to this discussion.
\begin{itemize}
\item ldgPad This is the landing pad.
\item lock This value is a mutex lock that protects vproc state.
\item cond This value is a condition variable that we use to put the vproc to sleep.
\item sleeping This flag is true when the vproc is sleeping.\footnote{It is only necessary for protocol 1.}
\item limPtr This value represents the heap-limit pointer. By setting this value to zero, we can force
  interrupt the vproc while it is running, and thus can force the vproc to receive any pending high-priority
  signals. We use the limit pointer to implement the Interrupt operation.
\end{itemize}

\begin{figure}
\begin{CCODE}
\begin{lstlisting}
struct struct_vproc {
    ...
    QueueItem_t   *ldgPad;
    Mutex_t	  lock;
    Cond_t	  wait;
    bool          sleeping;
    Value_t       limPtr;
    ...
};
typedef struct struct_vproc VProc_t;
\end{lstlisting}
\end{CCODE}
\caption{The vproc structure.}\label{fig:vproc-structure}
\end{figure}

\subsection{Protocol 1}\label{sec:protocol1}

\paragraph{Landing pad representation}
The landing pad is represented by either one of the values below.
\begin{itemize}
\item Empty stack.
\begin{CCODE}
\begin{lstlisting}
EMPTY
\end{lstlisting}
\end{CCODE}
\item A queue item consists of a fiber k and its fiber-local storage fls and the next queue item.
\begin{CCODE}
\begin{lstlisting}
QueueItem(k, fls, item)
    \end{lstlisting}
    \end{CCODE}
\end{itemize}

\paragraph{Send}
The Send operation (\figref{fig:protocol1-send}) has two phases: first it repeatedly attempts to place a
signal on the landing pad (lines 3-8), and once successful, it checks
whether the vproc needs to be woken up (lines 10-12).

\begin{figure}
\begin{CCODE}
\lstset{numbers=left}
\begin{lstlisting}
void Send (VProc_t *vp, Fiber_t *k, Value_t *fls)
{
  while (true) {
    QueueItem_t *ldgPadOrig = vp->ldgPad;
    QueueItem_t *ldgPadNew = Promote(QueueItem(k, fls, ldgPadOrig));
    QueueItem_t *x = CAS(&(vp->ldgPad), ldgPadOrig, ldgPadNew);
    if (x != ldgPadOrig) {
      continue;
    } else {
      if (vp->sleeping) {
        CondSignal(&(vp->wait));
      }
      return;
    }
  }
}
\end{lstlisting}
\end{CCODE}
\caption{Protocol 1 Send operation.}\label{fig:protocol1-send}
\end{figure}

\paragraph{Interrupt}
The Interrupt operation (\figref{fig:protocol1-interrupt}) is essentially identical to Send, except for the
instruction at line 13 that zeros out the limit pointer.

\begin{figure}
\begin{CCODE}
\lstset{numbers=left}
\begin{lstlisting}
void Interrupt (VProc_t *vp, Fiber_t *k, Value_t *fls)
{
  while (true) {
    QueueItem_t *ldgPadOrig = vp->ldgPad;
    QueueItem_t *ldgPadNew = Promote(QueueItem(k, fls, ldgPadOrig));
    QueueItem_t *x = CAS(&(vp->ldgPad), ldgPadOrig, ldgPadNew);
    if (x != ldgPadOrig) {
      continue;
    } else {
      if (vp->sleeping) 
        CondSignal(&(vp->wait));
      else
        vp->limPtr = PtrToValue(0);
      return;
    }
  }
}
\end{lstlisting}
\end{CCODE}
\caption{Protocol 1 Interrupt operation.}\label{fig:protocol1-interrupt}
\end{figure}

\paragraph{Receive}
The Recv operation (\figref{fig:protocol1-recv}) attempts to retrieve all pending signals from the
landing pad at once.
If the attempt fails or the landing pad is empty, Recv simply returns an empty list (lines 5 and 10).
But if successful, Recv set the landing pad to empty and returns the list of pending signals.

\begin{figure}
\begin{CCODE}
\lstset{numbers=left}
\begin{lstlisting}
QueueItem_t Recv (VProc_t *host)
{
  QueueItem_t *ldgPadOrig = host->ldgPad;
  if (ldgPadOrig == EMPTY)
    return PtrToValue(M_NIL);
  QueueItem_t *x = CAS(&(host->ldgPad), ldgPadOrig, EMPTY);
  if (x == ldgPadOrig)
    return PtrToValue(ldgPadOrig);
  else
    return PtrToValue(M_NIL);
}
\end{lstlisting}
\end{CCODE}

\caption{Protocol 1 Recv operation.}\label{fig:protocol1-recv}
\end{figure}

\paragraph{Sleep}
The Sleep operation (\figref{fig:protocol1-sleep}) puts the vproc to sleep by 
setting the sleeping flag to true and subsequently waiting until the landing
pad becomes nonempty.
One subtelty is that the assignment to sleeping (line 4) must be visible
to other vprocs before checking the landing pad (line 5).
So on a processor without sequential consistency, we need an instruction that flushes 
the write buffer.
An atomic compare-and-swap at line 4 would suffice, but any lighter-weight instruction
that flushes the write buffer is preferable.

\paragraph{Correctness}
The correctness of this protocol is apparent from the following observation.
If the vproc sees that its landing pad is empty (line 6 of \figref{fig:protocol1-send}), 
then the vproc appears to be sleeping to the other vprocs.
Thus, it must be the case that all subsequent sends to that vproc are garanteed to
wake the vproc from its sleeping state (line 11 of \figref{fig:protocol1-send}).

\begin{figure}
\begin{CCODE}
\lstset{numbers=left}
\begin{lstlisting}
void Sleep (VProc_t *host)
{
  MutexLock(&(host->lock));
    host->sleeping = true;
    /* Flush all pending writes. */
    while (host->ldgPad == EMPTY)
      CondWait(&(host->wait), &(host->lock));
    host->sleeping = false;
  MutexUnlock(&(host->lock));
}
    \end{lstlisting}
    \end{CCODE}

\caption{Protocol 1: Sleep operation.}\label{fig:protocol1-sleep}
\end{figure}

\subsection{Protocol 2}\label{sec:protocol2}

\paragraph{Landing pad representation}
The landing pad is represented the same way as in protocol 1, except that it 
contains an additional state called SLEEPING.

\paragraph{Send}
The Send operation (\figref{fig:protocol2-sleep}) takes one of two based on the assumed
vproc state:
\begin{itemize}
\item \emph{The vproc is assumed awake (lines 6-11).} We attempt to push a signal on the remote vproc's landing pad (lines 6-7), and
if the push fails, we retry the operation (line 11).
\item \emph{The vproc is assumed sleeping (lines 13-21).} We obtain a mutex lock from the vproc, and test
whether it is still sleeping.
If so we place the signal on its landing pad and wake the vproc (lines 18-19), 
but otherwise release the lock and retry (lines 15-16).
\end{itemize}

\begin{figure}
\begin{CCODE}
\lstset{numbers=left}
\begin{lstlisting}
void Send (VProc_t *vp, Fiber_t *k, Value_t *fls)
{
  while (true) {
    QueueItem_t *ldgPadOrig = vp->ldgPad;
    if (ldgPadOrig != SLEEPING) {
      QueueItem_t *ldgPadNew = Promote(QueueItem(k, fls, ldgPadOrig));
      QueueItem_t *x = CAS(&(vp->ldgPad), ldgPadOrig, ldgPadNew);
      if (x == ldgPadOrig)
	return;
      else
	continue;
    } else {            /* (ldgPadOrig == SLEEPING) */
      MutexLock(&(vp->lock));
        if (vp->ldgPad != SLEEPING) {
          MutexUnlock(&(vp->lock));
          continue;
        }
        vp->ldgPad = Promote(QueueItem(k, fls, EMPTY));
        CondSignal(&(vp->wait));
      MutexUnlock(&(vp->lock));
      return;
    }
  }
}
\end{lstlisting}
\end{CCODE}
\caption{Protocol 2 Send operation.}\label{fig:protocol2-send}
\end{figure}

\paragraph{Interrupt}
The Interrupt operation (\figref{fig:protocol2-interrupt}) is identical to the Send operation,
except that we zero out the limit pointer at line 9.

\begin{figure}
\begin{CCODE}
\lstset{numbers=left}
\begin{lstlisting}
void Interrupt (VProc_t *vp, Fiber_t *k, Value_t *fls)
{
  while (true) {
    QueueItem_t *ldgPadOrig = vp->ldgPad;
    if (ldgPadOrig != SLEEPING) {
      QueueItem_t *ldgPadNew = Promote(QueueItem(k, fls, ldgPadOrig));
      QueueItem_t *x = CAS(&(vp->ldgPad), ldgPadOrig, ldgPadNew);
      if (x == ldgPadOrig) {
        vp->ldgPad = PtrToValue(0);
	return;
      } else {
	continue;
      }
    } else {            /* (ldgPadOrig == SLEEPING) */
      MutexLock(&(vp->lock));
        if (vp->ldgPad != SLEEPING) {
          MutexUnlock(&(vp->lock));
          continue;
        }
        vp->ldgPad = Promote(QueueItem(k, fls, EMPTY));
        CondSignal(&(vp->wait));
      MutexUnlock(&(vp->lock));
      return;
    }
  }
}
\end{lstlisting}
\end{CCODE}
\caption{Protocol 2 Interrupt operation.}\label{fig:protocol2-interrupt}
\end{figure}

\paragraph{Receive}
The Recv operation is identical to protocol 1, under the assumption that Recv is never called while
the vproc is in a sleeping state.

\paragraph{Sleep}
The Sleep operation (\figref{fig:protocol2-sleep}) acquires the lock
and then attempts to mark the state as sleeping (lines 3-4).
If this step succeeds, the vproc sleeps until a the landing pad becomes
nonempty (lines 5-6).
Once the vproc has woken up, it releases the lock (line 7).

\begin{figure}
\begin{CCODE}
\lstset{numbers=left}
\begin{lstlisting}
void Sleep (VProc_t *host)
{
  MutexLock(&(vp->lock));
    QueueItem_t *x = CAS(&(vp->ldgPad), EMPTY, SLEEPING);
    while (vp->ldgPad == SLEEPING)
      CondWait(&(vp->wait), &(vp->lock));
  MutexUnlock(&(vp->lock));
}
    \end{lstlisting}
    \end{CCODE}
\caption{Protocol 2: Sleep operation.}\label{fig:protocol2-sleep}
\end{figure}

\paragraph{Correctness}
The key observation for correctness is the following: if the vproc succeeds in 
entering a sleep state (line 4 \figref{fig:protocol2-sleep}), then exactly one other vproc executing a Send operation sees 
that this is the case (line 14 of \figref{fig:protocol2-send}).
Thus, if another vproc performs a Send operation, the destination vproc must always
leave its sleep state.

\subsection{Evaluation}\label{sec:evaluation}
Protocol 1 is conceptually simpler and requires fewer lines of code.
On the other hand, protocol 2 benefits from a potentially faster Send operation.
In the common case where the vproc is awake, a protocol-2 Send requires one less memory reference.

\section{Global garbage collection}\label{sec:global-gc}
Figure \ref{fig:global-gc-protocol} shows the protocol for starting a global garbage
collection.
The protocol assigns one vproc to be the leader.
The leader is responsible to initialize global state values and to notify other vprocs
that a collection is imminent.
Non-leader vprocs must participate in every collection, whether they are awake or asleep.

\paragraph{Global collector state}
Below is global state (shared by all vprocs) that we use in the protocol.
\begin{itemize}
  \item Mutex lock for the state.
    \begin{CCODE}
    \begin{lstlisting}
      static Mutex_t GCLock;
        \end{lstlisting}
    \end{CCODE}
  \item Condition variable for the lead vproc.
    \begin{CCODE}
    \begin{lstlisting}
      static Cond_t LeaderWait;
        \end{lstlisting}
    \end{CCODE}
  \item Condition variable for the non-lead vprocs.
    \begin{CCODE}
    \begin{lstlisting}
      static Cond_t FollowerWait;
        \end{lstlisting}
    \end{CCODE}
  \item Number of vprocs ready to begin a global collection.
    \begin{CCODE}
    \begin{lstlisting}
      static int nReadyForGC;
        \end{lstlisting}
    \end{CCODE}
  \item N-way barrier vprocs must pass before the collection can complete.
    \begin{CCODE}
    \begin{lstlisting}
      static Barrier_t GCBarrier;
        \end{lstlisting}
    \end{CCODE}
  \item True when a global collection is in progress.
    \begin{CCODE}
    \begin{lstlisting}
      static bool GlobalGCInProgress;
        \end{lstlisting}
    \end{CCODE}
\end{itemize}

\figref{fig:global-gc-protocol} shows the protocol for performing a global collection.
The protocol begins by assigning the vproc as lead or non-lead.
The lead vproc first initializes the state (lines 8-11) and then notifies the
other vprocs that a global collection is in progress (lines 21-23).
\footnote{The dummy fiber is a trivial fiber that we use to wake a vproc to participate
in a global collection.}
The leader then waits (lines 25-26) for the other vprocs to add their memory pages to the
from-space list (line 18).
Once all vprocs have passed this initialization phase (lines 3-19), the global collection
can begin (line 30).
The barrier (line 33) marks the point that the collection ends.

\begin{figure}
\begin{CCODE}
\lstset{numbers=left}
\begin{lstlisting}
void StartGlobalGC (VProc_t *self, Value_t **roots)
{
  bool leaderVProc;
  int nVProcs = GetNumVProcs();
  int nOtherVProcs = nVProcs - 1;
  MutexLock(&GCLock);
    if (!GlobalGCInProgress) {
      leaderVProc = true;
      GlobalGCInProgress = true;
      nReadyForGC = 0;
      BarrierInit(&GCBarrier, nVProcs);
    } else {
      leaderVProc = false;
      if (++nReadyForGC == nOtherVProcs)
         CondSignal(&LeaderWait);
      CondWait(&FollowerWait, &GCLock);
    }
  /* ... adding the vproc's pages to the from-space list ... */
  MutexUnlock(&GCLock);
  if (leaderVProc) {
    for (int i = 0; i < nVProcs; i++)
      if (VProcs[i] != self)
        Interrupt(vp, dummyCont, M_NIL);
    MutexLock(&GCLock);
      while (nReadyForGC < nOtherVProcs)
        CondWait(&LeaderWait, &GCLock);
      CondBroadcast(&FollowerWait, &GCLock);
    MutexUnlock(&GCLock);    
  }
  /* ... running the global garbage collector ... */
  if (leaderVProc)
    GlobalGCInProgress = false;
  BarrierWait(&GCBarrier);
}
    \end{lstlisting}
    \end{CCODE}
\caption{The global garbage collection protocol.}\label{fig:global-gc-protocol}
\end{figure}

\end{document}  
