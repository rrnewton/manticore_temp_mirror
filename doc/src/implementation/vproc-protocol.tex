\documentclass[11pt]{article}

\setlength{\textwidth}{6in}
\setlength{\oddsidemargin}{0.25in}
\setlength{\textheight}{9.0in}
\setlength{\topmargin}{-0.75in}

\input{../common/common-defs}
\usepackage{graphicx}
\usepackage{listings}

\title{VProc protocol}
\author{The Manticore Group}
\date{Draft of \today}

\begin{document}
\maketitle

\section{Overview}
This document describes the protocol for managing vprocs.

\section{Signaling and sleeping}\label{sec:signaling-and-sleeping}
This section presents two alternative signaling protocols for vprocs.
Both protocols have their advantages, and here we describe both to evaluate
which is most appropriate for the Manticore implementation.
The rest of this section is structured as follows.
In this secion we outline the interface and semantics of the protocol.
Section \ref{sec:protocol1} describes the first protocol, and section
\ref{sec:protocol2} describes the second protocol.
Then \secref{sec:evaluation} compares the protocols.

\paragraph{Signals}
A signal is a fiber paired with fiber-local storage.
To handle a signal, a vproc initializes the fiber-local storage and runs the fiber to completion.

\paragraph{Landing pad}
The \emph{landing pad} is a lock-free linked list of incoming signals.
Each vproc owns a landing pad, and has access to all the other remote landing pads.
The landing pad supports two operations.
\begin{enumerate}
  \item Push a message on a remote landing pad.
  \item Pop all messages from the local landing pad.
\end{enumerate}

\paragraph{Sleeping}
When there is nothing to do, a vproc enters a temporary sleeping state, which lasts until either a
signal arrives on the vproc's landing pad or a global garbage collection is initiated by some other
vproc.
We avoid busy waiting by waiting on a condition variable provided by the Pthreads
library.
Unfortunately, the fact that the landing pad is a lock-free data structure causes
a problem:
signals might arrive after the vproc has checked the landing pad but before the vproc has
begun waiting on the condition variable.
Thus, there is a potential race condition that would allow the vproc to wait indefinitely,
even when work becomes available.
Our protocols must address this race condition by using some additional
synchronization.

\paragraph{Vproc operations}
Below are the operations that the vproc protocol must provide.
\begin{itemize}
  \item Place a signal on the landing pad of a remote vproc.
    \footnote{Note that this operation has undefined behavior when applied to the host vproc.}
    \lstset{language=C}
    \lstset{commentstyle=\textit}
    \begin{lstlisting}
      void Send (VProc_t *vp, Fiber_t *k, Value_t *fls);
    \end{lstlisting}
  \item Receive signals from the host vproc's landing pad. 
    \footnote{Note that this operation has undefined behavior when applied to a remote vproc.}
    \lstset{language=C}
    \lstset{commentstyle=\textit}
    \begin{lstlisting}
      Value_t Recv (VProc_t *host);
    \end{lstlisting}
  \item Put the host vproc to sleep until its landing pad becomes nonempty.
    \footnote{Note that this operation has undefined behavior when applied to a remote vproc.}
    \lstset{language=C}
    \lstset{commentstyle=\textit}
    \begin{lstlisting}
      void Sleep (VProc_t *host);
    \end{lstlisting}
\end{itemize}

We choose to minimize the synchronization overhead of Send even at the expense of
increasing the overhead of Sleep.
The rationale is that, in the common case, the Sleep operation affects idle vprocs, whereas
the Send function affects working vprocs.

\paragraph{Vproc components}
The per vproc structure VProc\_t contains four components that are relevant to this discussion.
The sleeping flag is only necessary for the first protocol.
\lstset{language=C}
\lstset{commentstyle=\textit}
\begin{lstlisting}
struct struct_vproc {
    ...
    Value_t     ldgPad;
    Mutex_t	lock;
    Cond_t	wait;
    bool        sleeping;
    ...
};
typedef struct struct_vproc VProc_t;
\end{lstlisting}

\subsection{Protocol 1}\label{sec:protocol1}

\paragraph{Landing pad representation}
The landing pad is represented by one of the values below, where EMPTY
denotes an empty stack, k is a fiber, fls is fiber-local storage, and stk
is a queue item.
\lstset{language=C}
\lstset{commentstyle=\textit}
\begin{lstlisting}
EMPTY
QueueItem(k, fls, stk)
\end{lstlisting}

\paragraph{Send}
The Send operation (\figref{fig:protocol1-send}) has two phases: first it repeatedly attempts to place a
signal on the landing pad (lines 3-8), and once successful, it checks
whether the vproc needs to be woken up (lines 10-12).

\begin{figure}
\lstset{language=C}
\lstset{commentstyle=\textit}
\lstset{numbers=left}
\begin{lstlisting}
void Send (VProc_t *vp, Fiber_t *k, Value_t *fls)
{
  while (true) {
    Value_t *ldgPadOrig = vp->ldgPad;
    Value_t *ldgPadNew = Promote(QueueItem(k, fls, ldgPadOrig));
    Value_t *x = CAS(&(vp->ldgPad), ldgPadOrig, ldgPadNew);
    if (x != ldgPadOrig) {
      continue;
    } else {
      if (vp->sleeping) {
        CondSignal(&(vp->wait));
      }
      return;
    }
  }
}
\end{lstlisting}
\caption{Protocol 1 Send operation.}\label{fig:protocol1-send}
\end{figure}

\paragraph{Receive}
The Recv operation (\figref{fig:protocol1-recv}) attempts to retrieve all pending signals from the
landing pad at once.
If the attempt fails or the landing pad is empty, Recv simply returns an empty list (lines 5 and 10).
But if successful, Recv set the landing pad to empty and returns the list of pending signals.

\begin{figure}
\lstset{language=C}
\lstset{commentstyle=\textit}
\lstset{numbers=left}
\begin{lstlisting}
Value_t Recv (VProc_t *host)
{
  Value_t *ldgPadOrig = host->ldgPad;
  if (ldgPadOrig == EMPTY)
    return PtrToValue(M_NIL)_;
  Value_t *x = CAS(&(host->ldgPad), ldgPadOrig, EMPTY);
  if (x == ldgPadOrig)
    return PtrToValue(ldgPadOrig);
  else
    return PtrToValue(M_NIL);
}
\end{lstlisting}
\caption{Protocol 1 Recv operation.}\label{fig:protocol1-recv}
\end{figure}

\paragraph{Sleep}
The Sleep operation (\figref{fig:protocol1-sleep}) puts the vproc to sleep by 
setting the sleeping flag to true and subsequently waiting until the landing
pad becomes nonempty.
One subtelty is that the assignment to sleeping (line 4) must be visible
to other vprocs before checking the landing pad (line 5).
So on a processor without sequential consistency, we need an instruction that flushes 
the write buffer.
An atomic compare-and-swap at line 4 would suffice, but any lighter-weight instruction
that flushes the write buffer is preferable.

\paragraph{Correctness}
The correctness of this protocol is apparent from the following observation.
If the vproc sees that its landing pad is empty (line 6 of \figref{fig:protocol1-send}), 
then the vproc appears to be sleeping to the other vprocs.
Thus, it must be the case that all subsequent sends to that vproc are garanteed to
wake the vproc from its sleeping state (line 11 of \figref{fig:protocol1-send}).

\begin{figure}
\lstset{language=C}
\lstset{commentstyle=\textit}
\lstset{numbers=left}
\begin{lstlisting}
void Sleep (VProc_t *host)
{
  MutexLock(&(host->lock));
    host->sleeping = true;
    /* Flush all pending writes. */
    while (host->ldgPad == EMPTY)
      CondWait(&(host->wait), &(host->lock));
    host->sleeping = false;
  MutexUnlock(&(host->lock));
}
\end{lstlisting}
\caption{Protocol 1: Sleep operation.}\label{fig:protocol1-sleep}
\end{figure}

\subsection{Protocol 2}\label{sec:protocol2}

\paragraph{Landing pad representation}
The landing pad is represented the same way as in protocol 1, except that it 
contains an additional SLEEPING state.
\lstset{language=C}
\lstset{commentstyle=\textit}
\begin{lstlisting}
EMPTY
SLEEPING
QueueItem(k, fls, stk)
\end{lstlisting}

\paragraph{Send}
The Send operation (\figref{fig:protocol2-sleep}) takes one of two based on the assumed
vproc state:
\begin{itemize}
\item \emph{The vproc is assumed awake (lines 6-11).} We attempt to push a signal on the remote vproc's landing pad (lines 6-7), and
if the push fails, we retry the operation (line 11).
\item \emph{The vproc is assumed sleeping (lines 13-21).} We obtain a mutex lock from the vproc, and test
whether it is still sleeping.
If so we place the signal on its landing pad and wake the vproc (lines 18-19), 
but otherwise release the lock and retry (lines 15-16).
\end{itemize}

\begin{figure}
\lstset{language=C}
\lstset{commentstyle=\textit}
\lstset{numbers=left}
\begin{lstlisting}
void Send (VProc_t *vp, Fiber_t *k, Value_t *fls)
{
  while (true) {
    Value_t *stk = vp->ldgPad;
    if (stk != SLEEPING) {
      Value_t *newStk = Promote(QueueItem(k, fls, stk));
      Value_t *x = CAS(&(vp->ldgPad), stk, newStk);
      if (x == stk)
	return;
      else
	continue;
    } else {            /* (stk == SLEEPING) */
      MutexLock(&(vp->lock));
        if (vp->ldgPad != SLEEPING) {
          MutexUnlock(&(vp->lock));
          continue;
        }
        vp->ldgPad = Promote(QueueItem(k, fls, EMPTY));
        CondSignal(&(vp->wait));
      MutexUnlock(&(vp->lock));
      return;
    }
  }
}
\end{lstlisting}
\caption{Protocol 2 Send operation.}\label{fig:protocol2-send}
\end{figure}

\paragraph{Receive}
The Recv operation is identical to protocol 1, under the assumption that Recv is never called while
the vproc is in a sleeping state.

\paragraph{Sleep}
The Sleep operation (\figref{fig:protocol2-sleep}) acquires the lock
and then attempts to mark the state as sleeping (lines 3-4).
If this step succeeds, the vproc sleeps until a the landing pad becomes
nonempty (lines 5-6).
Once the vproc has woken up, it releases the lock (line 7).

\begin{figure}
\lstset{language=C}
\lstset{commentstyle=\textit}
\lstset{numbers=left}
\begin{lstlisting}
void Sleep (VProc_t *host)
{
  MutexLock(&(vp->lock));
    Value_t *x = CAS(&(vp->ldgPad), EMPTY, SLEEPING);
    while (vp->ldgPad == SLEEPING)
      CondWait(&(vp->wait), &(vp->lock));
  MutexUnlock(&(vp->lock));
}
\end{lstlisting}
\caption{Protocol 2: Sleep operation.}\label{fig:protocol2-sleep}
\end{figure}

\paragraph{Correctness}
The key observation for correctness is the following: if the vproc succeeds in 
entering a sleep state (line 4 \figref{fig:protocol2-sleep}), then exactly one other vproc executing a Send operation sees 
that this is the case (line 14 of \figref{fig:protocol2-send}).
Thus, if another vproc performs a Send operation, the destination vproc must always
leave its sleep state.

\subsection{Evaluation}\label{sec:evaluation}
Protocol 1 is conceptually simpler and requires fewer lines of code.
Protocol 2, however, is likely to be faster on the common case, where the vproc is
already awake.
In this case, protocol 2 makes one less remote memory reference than protocol 1.

\section{Global garbage collection}\label{sec:global-gc}
Figure \ref{fig:global-gc-protocol} shows the protocol for starting a global garbage
collection.
The protocol assigns one vproc to be the leader.
The leader is responsible to initialize global state values and to notify other vprocs
that a collection is imminent.
Non-leader vprocs must participate in every collection, whether they are awake or asleep.

\paragraph{Global collector state}
Below is global state (shared by all vprocs) that we use in the protocol.
\begin{itemize}
  \item Mutex lock for the state.
    \lstset{language=C}
    \lstset{commentstyle=\textit}
    \begin{lstlisting}
      static Mutex_t		GCLock;
    \end{lstlisting}
  \item Condition variable for the lead vproc.
    \lstset{language=C}
    \lstset{commentstyle=\textit}
    \begin{lstlisting}
      static Cond_t		LeaderWait;
    \end{lstlisting}
  \item Condition variable for the non-lead vprocs.
    \lstset{language=C}
    \lstset{commentstyle=\textit}
    \begin{lstlisting}
      static Cond_t		FollowerWait;
    \end{lstlisting}
  \item Number of vprocs ready to begin a global collection.
    \lstset{language=C}
    \lstset{commentstyle=\textit}
    \begin{lstlisting}
      static int		nReadyForGC;
    \end{lstlisting}
  \item N-way barrier vprocs must pass before the collection can complete.
    \lstset{language=C}
    \lstset{commentstyle=\textit}
    \begin{lstlisting}
      static Barrier_t	GCBarrier;
    \end{lstlisting}
  \item True when a global collection is in progress.
    \lstset{language=C}
    \lstset{commentstyle=\textit}
    \begin{lstlisting}
      static bool		GlobalGCInProgress;
    \end{lstlisting}
\end{itemize}

\figref{fig:global-gc-protocol} shows the protocol for performing a global collection.
The protocol begins by assigning the vproc as lead or non-lead.
The lead vproc first initializes the state (lines 8-11) and then notifies the
other vprocs that a global collection is in progress (lines 21-23).
\footnote{The dummy fiber is a trivial fiber that we use to wake a vproc to participate
in a global collection.}
The leader then waits (lines 25-26) for the other vprocs to add their memory pages to the
from-space list (line 18).
Once all vprocs have passed this initialization phase (lines 3-19), the global collection
can begin (line 30).
The barrier (line 33) marks the point that the collection ends.

\begin{figure}
\lstset{language=C}
\lstset{commentstyle=\textit}
\lstset{numbers=left}
\begin{lstlisting}
void StartGlobalGC (VProc_t *self, Value_t **roots)
{
  bool leaderVProc;
  int nVProcs = GetNumVProcs();
  int nOtherVProcs = nVProcs - 1;
  MutexLock(&GCLock);
    if (!GlobalGCInProgress) {
      leaderVProc = true;
      GlobalGCInProgress = true;
      nReadyForGC = 0;
      BarrierInit(&GCBarrier, nVProcs);
    } else {
      leaderVProc = false;
      if (++nReadyForGC == nOtherVProcs)
         CondSignal(&LeaderWait);
      CondWait(&FollowerWait, &GCLock);
    }
  /* ... adding the vproc's pages to the from-space list ... */
  MutexUnlock(&GCLock);
  if (leaderVProc) {
    for (int i = 0; i < nVProcs; i++)
      if (VProcs[i] != self)
        Send(vp, vp->dummyCont, M_NIL);
    MutexLock(&GCLock);
      while (nReadyForGC < nOtherVProcs)
        CondWait(&LeaderWait, &GCLock);
      CondBroadcast(&FollowerWait, &GCLock);
    MutexUnlock(&GCLock);    
  }
  /* ... running the global garbage collector ... */
  if (leaderVProc)
    GlobalGCInProgress = false;
  BarrierWait(&GCBarrier);
}
\end{lstlisting}
\caption{The global garbage collection protocol.}\label{fig:global-gc-protocol}
\end{figure}

\end{document}  
