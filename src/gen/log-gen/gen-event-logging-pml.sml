(* gen-logging-pml.sml
 *
 * COPYRIGHT (c) 2009 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Generate the "inline-log.h" file.
 *)

structure GenEventLoggingPML : GENERATOR =
  struct

    structure Sig = EventSig
    structure Map = Sig.Map
    structure F = Format

    val template = "event_logging_pml.in"
    val path = "src/lib/basis/misc/event-logging.pml"

  (* filter out "new-id" arguments, since they are generated by the logging code *)
    fun filterArgs args = List.filter (not o Sig.isNewIdArg) args

    fun smallType (args : Sig.arg_desc list) =
	case args
	 of {ty=Sig.WORD8, ...}::args => true
	  | {ty=Sig.WORD16,...}::args => true
	  | x :: args => smallType args
	  | [] => false

    fun genExtern outS (sign, {isSource, args}) =
	let fun pr s = TextIO.output(outS, s)
	    fun prl l = TextIO.output(outS, concat l)
	    fun prf (fmt, l) = TextIO.output(outS, F.format fmt l)
	    fun genParams [] = ""
	      | genParams ((_, ty)::r) =
		case ty
		 of Sig.ADDR => ", void *" ^ genParams r
		  | Sig.INT => ", int" ^ genParams r
		  | Sig.WORD => ", int" ^ genParams r
		  | Sig.FLOAT => ", float" ^ genParams r
		  | Sig.DOUBLE => ", double" ^ genParams r
		  | Sig.EVENT_ID => ", long" ^ genParams r
		  | Sig.NEW_ID => genParams r
		  | Sig.WORD16 => ", short" ^ genParams r
		  | Sig.WORD8 => ", byte" ^ genParams r
		  | Sig.STR _ => ", void*" ^ genParams r
	    val params = genParams args
	    val retType = if isSource then "long" else "void"
	in
	    prl ["    extern ", retType, " LogEvent", sign, "(void*, int", params, ");\n"]
	end
	    
(* generate the inline logging function for a given signature *)
    fun genForSig outS (sign, {isSource, args}) = let
	  fun pr s = TextIO.output(outS, s)
	  fun prl l = TextIO.output(outS, concat l)
	  fun prf (fmt, l) = TextIO.output(outS, F.format fmt l)
	(* generate params for the event arguments *)
	  fun genParams([], i, params, args) = (params, args)
	    | genParams((_, ty)::r, i, params, args) =
	      let val param = ", a" ^ Int.toString i
	      in case ty
		  of Sig.ADDR => genParams(r, i+1, params ^ param ^ " : any", args ^ param)
		   | Sig.INT => genParams(r, i+1, params ^ param ^ " : int", args ^ param)
		   | Sig.WORD => genParams(r, i+1, params ^ param ^ " : int", args ^ param)
		   | Sig.FLOAT => genParams(r, i+1, params ^ param ^ " : float", args ^ param)
		   | Sig.DOUBLE => genParams(r, i+1, params ^ param ^ " : double", args ^ param)
		   | Sig.EVENT_ID => genParams(r, i+1, params ^ param ^ " : any", args ^ param)
		   | Sig.NEW_ID => genParams(r, i+1, params, args)
		   | Sig.WORD16 => genParams(r, i+1, params ^ param ^ " : short", args ^ param)
		   | Sig.WORD8 => genParams(r, i+1, params ^ param ^ " : byte", args ^ param)
		   | Sig.STR _ => genParams(r, i+1, params ^ param ^ " : any", args ^ param)
	      end
	  val (params, args) = genParams(args, 0, "", "")
    in
	if isSource
	then
	    (
	      prl ["\tdefine inline @log-event", sign, "(vp : vproc, evt : int", params, ") : long = \n"];
	      pr "\t\tlet vp : vproc = host_vproc\n";
	      prl ["\t\tlet new_id : long = ccall LogEvent", sign, "(vp, evt", args, ")\n"];
	      pr "\t\treturn(new_id);\n\n"
	    )
	else
	    (
	      prl ["\tdefine inline @log-event", sign, "(vp : vproc, evt : int", params, ") : () = \n"];
	      pr "\t\tlet vp : vproc = host_vproc\n";
	      prl ["\t\tdo ccall LogEvent", sign, "(vp, evt", args, ")\n"];
	      pr "\t\treturn();\n\n"
	    )
    end
						      
  (* generate an event-specific logging HLOp *)
    fun genLogHLOp outS (evt as LoadFile.EVT ed) = let
	  fun pr s = TextIO.output(outS, s)
	  fun prl l = TextIO.output(outS, concat l)
	  val isSource = LoadFile.hasAttr LoadFile.ATTR_SRC evt
	  val retTy = if isSource then "long" else "()"
	  fun argToBOMTy ({ty, ...} : Sig.arg_desc) = (case ty
		 of Sig.ADDR => "any"
		  | Sig.INT => "int"
		  | Sig.WORD => "int"
		  | Sig.FLOAT => "float"
		  | Sig.DOUBLE => "double"
		  | Sig.NEW_ID => "long"
		  | Sig.EVENT_ID => "long"
		  | Sig.WORD16 => "short"
		  | Sig.WORD8 => "byte"
		  | Sig.STR n => raise Fail "strings not supported yet"
		(* end case *))
	  val args = filterArgs  (Sig.sortArgs(#args ed))
    in
	    prl ["\tdefine inline @log-", #name ed, " (vp : vproc"];
	    List.app (fn a => prl [", ", #name a, " : ", argToBOMTy a]) args;
	    prl [") : ", retTy, " = \n"];
	  (* invoke generic HLOp *)
	    if isSource
	      then pr "\t    let id : long = @log-event"
	      else pr "\t    do @log-event";
	    prl [#sign ed, " (vp, ", #name ed, "Evt"];
	    List.app (fn a => prl [", ", #name a]) args;
	    pr ")\n";
	  (* return result (if any) *)
	    if isSource
	      then pr "\t    return (id)\n"
	      else pr "\t    return ()\n";
	    pr "\t  ;\n"
	  end

  (* generate an event-specific logging HLOp that has been wrapped to be called by PML *)
    fun genWrappedLogHLOp outS (evt as LoadFile.EVT ed) = let
	  fun pr s = TextIO.output(outS, s)
	  fun prl l = TextIO.output(outS, concat l)
	  val isSource = LoadFile.hasAttr LoadFile.ATTR_SRC evt
	  val retTy = if isSource then "[long]" else "unit"
	  fun argToBOMTy ({ty, ...} : Sig.arg_desc) = (case ty
		 of Sig.ADDR => "any"
		  | Sig.INT => "int"
		  | Sig.WORD => "int"
		  | Sig.FLOAT => "float"
		  | Sig.DOUBLE => "double"
		  | Sig.NEW_ID => "long"
		  | Sig.EVENT_ID => "long"
		  | Sig.WORD16 => "short"
		  | Sig.WORD8 => "byte"
		  | Sig.STR n => raise Fail "strings not supported yet"
		(* end case *))
	  fun argToWrappedTy ({ty, ...} : Sig.arg_desc) = (case ty
		 of Sig.ADDR => "any"
		  | Sig.INT => "[int]"
		  | Sig.WORD => "[int]"
		  | Sig.FLOAT => "[float]"
		  | Sig.DOUBLE => "[double]"
		  | Sig.NEW_ID => "[long]"
		  | Sig.EVENT_ID => "[long]"
		  | Sig.WORD16 => "[short]"
		  | Sig.WORD8 => "[byte]"
		  | Sig.STR n => raise Fail "strings not supported yet"
		(* end case *))
	  fun isWrapped ({ty, ...} : Sig.arg_desc) = (case ty
		 of Sig.ADDR => false
		  | _ => true
		(* end case *))
	  val args = filterArgs  (Sig.sortArgs(#args ed))
    in
	    prl ["\tdefine inline @w-log-", #name ed, " ("];
	    case args
	     of [] => pr "_ : unit"
	      | [arg] => prl [#name arg, " : ", argToWrappedTy arg]
	      | arg::rest => (
		  prl ["arg : ["];
		  pr (argToWrappedTy arg);
		  List.app (fn a => prl[", ", argToWrappedTy a]) rest;
		  pr "]")
	    (* end case *);
	    prl [" / _ : exh) : ", retTy, " = \n"];
	  (* unwrapping of arguments *)
	    case args
	     of [] => ()
	      | [arg] => if isWrapped arg
		    then prl [
			"\t    let ", #name arg, " : ", argToBOMTy arg, " = #0(", #name arg, ")\n"
		      ]
		    else ()
	      | args => let
		  fun f (arg, i) = (
			if isWrapped arg
			  then prl [
			      "\t    let ", #name arg, " : ", argToBOMTy arg, " = #0(#",
			      Int.toString i, "(arg))\n"
			    ]
			  else ();
			i+1)
		  in
		    ignore (List.foldl f 0 args)
		  end
	    (* end case *);
	  (* invoke unwrapped HLOp *)
	    if isSource
	      then pr "\t    let id : long = @log-"
	      else pr "\t    do @log-";
	    prl [#name ed, " (host_vproc"];
	    List.app (fn a => prl[", ", #name a]) args;
	    pr ")\n";
	  (* wrap and return result (if any) *)
	    if isSource
	      then (
		pr "\t    let res : [long] = alloc (id)\n";
		pr "\t    return (res)\n")
	      else pr "\t    return (UNIT)\n";
	    pr "\t  ;\n"
	  end

  (* generate a dummy logging macro for when logging is disabled *)
    fun genDummyLogHLOp outS (evt as LoadFile.EVT ed) = let
	  fun pr s = TextIO.output(outS, s)
	  fun prl l = TextIO.output(outS, concat l)
	  val isSource = LoadFile.hasAttr LoadFile.ATTR_SRC evt
	  val retTy = if isSource then "long" else "()"
	  fun argToBOMTy ({ty, ...} : Sig.arg_desc) = (case ty
		 of Sig.ADDR => "any"
		  | Sig.INT => "int"
		  | Sig.WORD => "int"
		  | Sig.FLOAT => "float"
		  | Sig.DOUBLE => "double"
		  | Sig.NEW_ID => "long"
		  | Sig.EVENT_ID => "long"
		  | Sig.WORD16 => "short"
		  | Sig.WORD8 => "byte"
		  | Sig.STR n => raise Fail "strings not supported yet"
		(* end case *))
	  val args = filterArgs  (Sig.sortArgs(#args ed))
    in
	    prl ["\tdefine inline @log-", #name ed, " (_ : vproc"];
	    List.app (fn a => prl [", _ : ", argToBOMTy a]) args;
	    prl [") : ", retTy, " = "];
	  (* return result (if any) *)
	    if isSource
	      then pr "return (0 : long);\n"
	      else pr "return ();\n"
	  end
							    
  (* generate an event-specific logging function *)
    fun genLogFun outS (evt as LoadFile.EVT{name, args, ...}) = let
	fun pr s = TextIO.output(outS, s)
	fun prl l = TextIO.output(outS, concat l)
	val retTy = if LoadFile.hasAttr LoadFile.ATTR_SRC evt
		    then "long"
		    else "unit"
	fun argToTy ({ty, ...} : Sig.arg_desc) =
	    (case ty
	      of Sig.ADDR => "'a"  (* FIXME: what about multiple ADDR args *)
	       | Sig.INT => "int"
	       | Sig.WORD => "int"
	       | Sig.FLOAT => "float"
	       | Sig.DOUBLE => "double"
	       | Sig.NEW_ID => "long"
	       | Sig.EVENT_ID => "long"
	       | Sig.STR n => "string"
	       | Sig.WORD16 => "short"
	       | Sig.WORD8 => "byte"
	    (* end case *))
    in
	if smallType args
	then ()
	else (
	prl ["    val log", name, " : "];
	case filterArgs args
	 of [] => pr "unit"
	  | [arg] => pr(argToTy arg)
	  | arg::rest => (
	      prl ["(", argToTy arg];
	      List.app (fn a => prl [" * ", argToTy a]) rest;
	      pr ")")
	(* end case *);
	prl [" -> ", retTy, " = _prim (@w-log-", name, ")\n"])
    end
								    
    (* compute a mapping from signatures to their argument info from the list of event
     * descriptors.
     *)
    fun computeSigMap logDesc = let
	  val isSourceEvt = LoadFile.hasAttr LoadFile.ATTR_SRC
	  fun doEvent (evt as LoadFile.EVT{sign, args, ...}, map) = (case Map.find(map, sign)
		 of SOME _ => map
		  | NONE => let
		      val argInfo = {
			      isSource = isSourceEvt evt,
			      args = List.map (fn {loc, ty, ...} => (loc, ty)) args
			    }
		      in
			Map.insert (map, sign, argInfo)
		      end
		(* end case *))
	  in
	    LoadFile.foldEvents doEvent Map.empty logDesc
	  end

    fun hooks (outS, logDesc : LoadFile.log_file_desc) = let
	(* filter out the runtime-system-only events *)
	  val logDesc = LoadFile.filterEvents (not o (LoadFile.hasAttr LoadFile.ATTR_RT)) logDesc
	  val sigMap = computeSigMap logDesc
	  fun genericLogHLOps () = Map.appi (genForSig outS) sigMap
	  fun logHLOps () = LoadFile.applyToEvents (genLogHLOp outS) logDesc
	  fun wrappedHLOps () = LoadFile.applyToEvents (genWrappedLogHLOp outS) logDesc
	  fun dummyLogHLOps () = LoadFile.applyToEvents (genDummyLogHLOp outS) logDesc
	  fun logFunctions () = LoadFile.applyToEvents (genLogFun outS) logDesc
	  fun externs () = Map.appi (genExtern outS) sigMap
	  in [
	    ("GENERIC-LOG-HLOPS", genericLogHLOps),
	    ("LOG-HLOPS", logHLOps),
	    ("WRAPPED-LOG-HLOPS", wrappedHLOps),
	    ("DUMMY-LOG-HLOPS", dummyLogHLOps),
	    ("LOG-FUNCTIONS", logFunctions),
	    ("EXTERNS", externs)
	  ] end

  end
