(* gen-logging-pml.sml
 *
 * COPYRIGHT (c) 2009 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Generate the "inline-log.h" file.
 *)

structure GenLoggingPML : GENERATOR =
  struct

    structure Sig = EventSig
    structure Map = Sig.Map
    structure F = Format

    val template = "logging_pml.in"
    val path = "src/lib/basis/misc/logging.pml"

  (* generate the inline logging function for a given signature *)
    fun genForSig outS (sign, {isSource, args}) = let
	  fun pr s = TextIO.output(outS, s)
	  fun prl l = TextIO.output(outS, concat l)
	  fun prf (fmt, l) = TextIO.output(outS, F.format fmt l)
	(* generate params for the event arguments *)
	  fun genParams ([], _)= ()
	    | genParams ((_, ty)::r, i) = let
		fun next cty = (
		      prl [", ", cty, "a", Int.toString i];
		      genParams (r, i+1))
		in
		  case ty
		   of Sig.ADDR => next "any"
		    | Sig.INT => next "int"
		    | Sig.WORD => next "int"
		    | Sig.FLOAT => next "float"
		    | Sig.DOUBLE => next "double"
		    | Sig.EVENT_ID => next "long"
		    | Sig.NEW_ID => (* this value is generated by logging function *)
			genParams (r, i+1)
		    | Sig.STR _ => next "any"
		  (* end case *)
		end
	(* generate code to copy the event arguments into the event structure *)
	  fun genCopy ([], _) = ()
	    | genCopy ((loc, ty)::r, i) = let
		val param = "a" ^ Int.toString i
		val loc = loc - Sig.argStart
		val items = [F.WORD loc, F.STR param]
		in
		  pr "\t    ";
		  case ty
		   of Sig.ADDR => prf("do AdrStoreAdr(AdrAdd32(evt, %d), %s)\n", items)
		    | Sig.INT => prf("do AdrStoreI32(AdrAdd32(evt, %d), %s)\n", items)
		    | Sig.WORD => prf("do AdrStoreI32(AdrAdd32(evt, %d), %s)\n", items)
		    | Sig.FLOAT => prf("do AdrStoreF32(AdrAdd32(evt, %d), %s)\n", items)
		    | Sig.DOUBLE => prf("do AdrStoreF64(AdrAdd32(evt, %d), %s)\n", items)
		    | Sig.EVENT_ID => prf("do AdrStoreI64(AdrAdd32(evt, %d), %s)\n", items)
		    | Sig.NEW_ID => (
			pr "let newId : long = @NewEventId(vp)\n";
			pr "\t    ";
			prf("do AdrStoreI64(AdrAdd32(evt, %d), newId)\n", [F.WORD loc]))
		    | Sig.STR n => ()
		  (* end case *);
		  genCopy (r, i+1)
		end
	  in
	    prl ["\tdefine inline @", logEvent, sign, " (vp : vproc, evt : int"];
	    genParams (args, 0);
	    prl [") : ", if isSource then "long" else "()", " =\n"];
	    pr "\
	      \\t    let ep : addr(any) = @NextLogEvent(vp)\n\
	      \\t    do @LogTimestamp (ep)\n\
	      \\t    do AdrStoreI32(AdrAdd32(ep, %d), evt)\n\
	      \"
	    genCopy (args, 0);
	    if isSource
	      then pr "\t    return (newId);\n"
	      else pr "\t    return ()\n;
	    pr "\t  ;\n"
	  end

  (* generate an event-specific logging macro *)
    fun genLogMacro outS (LoadFile.EVT{id=0, ...}) = ()
      | genLogMacro outS (LoadFile.EVT ed) = let
	  fun pr s = TextIO.output(outS, s)
	  fun prl l = TextIO.output(outS, concat l)
	  fun prParams [] = ()
	    | prParams ((a : Sig.arg_desc)::r) = (prl [",", #name a]; prParams r)
	  fun prArgs [] = ()
	    | prArgs ((a : Sig.arg_desc)::r) = (prl [", (", #name a, ")"]; prArgs r)
	  in
	    prl ["#define Log", #name ed, "(vp"];
	    prParams (#args ed);
	    prl [") @LogEvent", #sign ed, " ((vp), ", #name ed, "Evt"];
	    prArgs (Sig.sortArgs(#args ed)); (* NOTE: location order here! *)
	    pr ")\n"
	  end

  (* generate a dummy logging macro for when logging is disabled *)
    fun genDummyLogMacro outS (LoadFile.EVT{id=0, ...}) = ()
      | genDummyLogMacro outS (LoadFile.EVT ed) = let
	  fun pr s = TextIO.output(outS, s)
	  fun prl l = TextIO.output(outS, concat l)
	  fun prParams [] = ()
	    | prParams ((a : Sig.arg_desc)::r) = (prl [",", #name a]; prParams r)
	  fun prArgs [] = ()
	    | prArgs ((a : Sig.arg_desc)::r) = (prl [", (", #name a, ")"]; prArgs r)
	  in
	    prl ["#define Log", #name ed, "(vp"];
	    prParams (#args ed);
	    pr ")\n"
	  end

  (* compute a mapping from signatures to their argument info from the list of event
   * descriptors.
   *)
    fun computeSigMap logDesc = let
	  fun doEvent (LoadFile.EVT{sign, args, genId, ...}, map) = (case Map.find(map, sign)
		 of SOME _ => map
		  | NONE => let
		      val argInfo = {
			      isSource = genId,
			      args = List.map (fn {loc, ty, ...} => (loc, ty)) args
			    }
		      in
			Map.insert (map, sign, argInfo)
		      end
		(* end case *))
	  in
	    LoadFile.foldEvents doEvent Map.empty logDesc
	  end

    fun hooks (outS, logDesc : LoadFile.log_file_desc) = let
	  val sigMap = computeSigMap logDesc
	  fun genericLogFuns () = Map.appi (genForSig outS) sigMap
	  fun logFunctions () = LoadFile.applyToEvents (genLogMacro outS) logDesc
	  fun dummyLogFunctions () = LoadFile.applyToEvents (genDummyLogMacro outS) logDesc
	  in [
	    ("GENERIC-LOG-FUNCTIONS", genericLogFuns),
	    ("LOG-FUNCTIONS", logFunctions),
	    ("DUMMY-LOG-FUNCTIONS", dummyLogFunctions)
	  ] end

  end
