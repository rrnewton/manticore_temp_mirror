#include "types.def"
#include "p-or.def"
#include "testing.def"
#include "vproc-queue.def"
#include "runtime-offsets.def"
#include "scheduling-ops.def"
#include "the.def"
#include "ltc.def"
#include "fiber-cancellation.def"

define inline @dtos (f : ml_double / exh : exh) : ml_string;

define @fib (n : int / exh : exh) : int =
  fun fib (n : [int] / exh : exh) : [int] =
      let raw : int = #0(n)
      if I32Lte(raw, 1)
         then
          let wlit : [int] = alloc(raw)
          return(wlit)
         else
           let raw : int = #0(n)
	   cont k(p : [int]) =
                let a : [int] = alloc(I32Sub(raw,2))
	        let q : [int] = apply fib(a / exh)
                let p : int = #0(p)
                let q : int = #0(q)
                let r : [int] = alloc(I32Add(p,q))
                return(r)           
           let a : [int] = alloc(I32Sub(raw,1))
           let p : [int] = apply fib(a / exh)
	  throw k(p)

  let n : [int] = alloc(n)
  let n : [int] = apply fib (n / exh)
  return(#0(n))
;

(* simulate our dval translation *)
define @fib-trans (n : int / exh : exh) : int =
  fun fib (n : [int] / exh : exh) : [int] =
      let raw : int = #0(n)
      if I32Lte(raw, 1)
         then
          let wlit : [int] = alloc(raw)
          return(wlit)
         else
           let raw : int = #0(n)

           cont retK (x : [int]) = return(x)
           let iv : ivar = @ivar-new(UNIT/ exh)

           fun bodyP (selFn : fun (unit / exh -> [int]) / exh : exh) : [int] =
	       let a : [int] = alloc(I32Sub(raw,2))
               let q : [int] = apply fib(a / exh)
               let p : [int] = apply selFn(UNIT / exh)
               let p : int = #0(p)
               let q : int = #0(q)
               let r : [int] = alloc(I32Add(p,q))
               return(r)           
	   cont k(_ : unit) =
                fun f (_ : unit / exh : exh) : [int] =
                    let v : any = @ivar-get(iv / exh)
                    let v : [int] = ([int])v
                    return(v)
                let x : [int] = apply bodyP(f / exh)
                throw retK(x)

           let _ : unit = @ltc-push-fiber(k / exh)
           
           (*eval the body *)
           let a : [int] = alloc(I32Sub(raw,1))
           let p : [int] = apply fib(a / exh)

           let x : bool = @ltc-pop(UNIT / exh)
           do case x
	       of TRUE => return()
		| FALSE =>
		  let arg : [ivar, any] = alloc(iv, p)
	          let _ : unit = @ltc-ivar-put(arg / exh)
                  @thread-exit(/exh)
              end

          fun f (_ : unit / exh : exh) : [int] =
              return(p)

	  apply bodyP (f / exh)

  let n : [int] = alloc(n)
  let n : [int] = apply fib (n / exh)
  return(#0(n))
;

(* translation w/ promote only *)
define @fib-promote-only (n : int / exh : exh) : int =
  let x : [int] = alloc(1)
  cont k(p : unit) = return(1)
  let c : ![cont(unit)] = alloc(k)
  let c : ![cont(unit)] = promote(c)

  let x1 :[int] = alloc(0)
  fun fib (n : [int] / exh : exh) : [int] =
      let raw : int = #0(n)
      if I32Lte(raw, 1)
         then
          let wlit : [int] = alloc(raw)
          return(wlit)
         else
           let raw : int = #0(n)

           cont retK (x : [int]) = return(x)
(*           let iv : ivar = @ivar-new(UNIT/ exh)*)

           fun bodyP (selFn : fun (unit / exh -> [int]) / exh : exh) : [int] =
	       let a : [int] = alloc(I32Sub(raw,2))
               let q : [int] = apply fib(a / exh)
               let p : [int] = apply selFn(UNIT / exh)
               let p : int = #0(p)
               let q : int = #0(q)
               let r : [int] = alloc(I32Add(p,q))
               return(r)           
	   cont k(_ : unit) =
                fun f (_ : unit / exh : exh) : [int] =
(*                    let v : any = @ivar-get(iv / exh) *)
                    let v : [int] = ([int])x
                    return(v)
                let x : [int] = apply bodyP(f / exh)
                throw retK(x)

(*           let _ : unit = @ltc-push-fiber(k / exh)*)
           
           let k : cont(unit) = (cont(unit)) k
           let k : cont(unit) = promote(k)
           do UPDATE(0, c, k)        

           (*eval the body *)
           let a : [int] = alloc(I32Sub(raw,1))
           let p : [int] = apply fib(a / exh)

(*           let x : bool = @ltc-pop(UNIT / exh)
           do case x
	       of TRUE => return()
		| FALSE =>
		  let arg : [ivar, any] = alloc(iv, p)
	          let _ : unit = @ltc-ivar-put(arg / exh)
                  @thread-exit(/exh)
              end
*)
          fun f (_ : unit / exh : exh) : [int] =
              return(p)

	  apply bodyP (f / exh)

  let n : [int] = alloc(n)
  let n : [int] = apply fib (n / exh)
  return(#0(n))
;

(* translation w/ promote only *)
define @fib-ivar-only (n : int / exh : exh) : int =
  cont k(p : unit) = return(1)
  let c : ![cont(unit)] = alloc(k)
  let c : ![cont(unit)] = promote(c)

  let x1 :[int] = alloc(0)
  fun fib (n : [int] / exh : exh) : [int] =
      let raw : int = #0(n)
      if I32Lte(raw, 1)
         then
          let wlit : [int] = alloc(raw)
          return(wlit)
         else
           let raw : int = #0(n)

           cont retK (x : [int]) = return(x)
           let iv : ivar = @ivar-new(UNIT/ exh)

           fun bodyP (selFn : fun (unit / exh -> [int]) / exh : exh) : [int] =
	       let a : [int] = alloc(I32Sub(raw,2))
               let q : [int] = apply fib(a / exh)
               let p : [int] = apply selFn(UNIT / exh)
               let p : int = #0(p)
               let q : int = #0(q)
               let r : [int] = alloc(I32Add(p,q))
               return(r)           
	   cont k(_ : unit) =
                fun f (_ : unit / exh : exh) : [int] =
                    let v : any = @ivar-get(iv / exh)
                    let v : [int] = ([int])v
                    return(v)
                let x : [int] = apply bodyP(f / exh)
                throw retK(x)

(*           let _ : unit = @ltc-push-fiber(k / exh)*)
           
           let k : cont(unit) = (cont(unit)) k
(*           let k : cont(unit) = promote(k)*)
           do UPDATE(0, c, k)        

           (*eval the body *)
           let a : [int] = alloc(I32Sub(raw,1))
           let p : [int] = apply fib(a / exh)

(*           let x : bool = @ltc-pop(UNIT / exh)
           do case x
	       of TRUE => return()
		| FALSE =>
		  let arg : [ivar, any] = alloc(iv, p)
	          let _ : unit = @ltc-ivar-put(arg / exh)
                  @thread-exit(/exh)
              end
*)
          fun f (_ : unit / exh : exh) : [int] =
              return(p)

	  apply bodyP (f / exh)

  let n : [int] = alloc(n)
  let n : [int] = apply fib (n / exh)
  return(#0(n))
;

(* measure cancelation *)
define @fib-cancel (n : int / exh : exh) : int =
  fun fib (n : [int] / exh : exh) : [int] =
      let raw : int = #0(n)
      if I32Lte(raw, 1)
         then
          let wlit : [int] = alloc(raw)
          return(wlit)
         else
           let raw : int = #0(n)

           cont retK (x : [int]) = return(x)
           let iv : ivar = @ivar-new(UNIT/ exh)

           let cc : cancel_cell = @cancel-cell(/exh)

           fun bodyP (selFn : fun (unit / exh -> [int]) / exh : exh) : [int] =
	       let a : [int] = alloc(I32Sub(raw,2))
               let q : [int] = apply fib(a / exh)
               let p : [int] = apply selFn(UNIT / exh)
               let p : int = #0(p)
               let q : int = #0(q)
               let r : [int] = alloc(I32Add(p,q))
               return(r)           
	   cont k(_ : unit) =
                fun f (_ : unit / exh : exh) : [int] =
                    let v : any = @ltc-ivar-get(iv, cc / exh)
                    let v : [int] = ([int])v
                    return(v)
                let x : [int] = apply bodyP(f / exh)
                cont k(_ : unit) = 
                      throw retK(x)
                let k : fiber = (fiber)k
                let _ : unit = @ltc-push-fiber(k / exh)
                @thread-exit(/exh)

          fun cleanupFun () : () = 
               return ()
           let k : fiber = @cancelable-fiber(cc, k, cleanupFun / exh)
           
           let _ : unit = @ltc-push-fiber(k / exh)
           
           (*eval the body *)
           let a : [int] = alloc(I32Sub(raw,1))
           let p : [int] = apply fib(a / exh)

           let x : bool = @ltc-pop(UNIT / exh)
           do case x
	       of TRUE => return()
		| FALSE =>
		  let arg : [ivar, any] = alloc(iv, p)
	          let _ : unit = @ltc-ivar-put(arg / exh)
                  @thread-exit(/exh)
              end

          fun f (_ : unit / exh : exh) : [int] =
              return(p)

	  apply bodyP (f / exh)

  let n : [int] = alloc(n)
  let n : [int] = apply fib (n / exh)
  return(#0(n))
;

define @fib-promote (n : int / exh : exh) : int =
  cont k(p : [int]) = return(1)
  let c : ![cont([int])] = alloc(k)
  let c : ![cont([int])] = promote(c)

  fun fib (n : [int] / exh : exh) : [int] =
      let raw : int = #0(n)
      if I32Lte(raw, 1)
         then
          let wlit : [int] = alloc(raw)
          return(wlit)
         else
           let raw : int = #0(n)
	   cont k(p : [int]) =
                let a : [int] = alloc(I32Sub(raw,2))
	        let q : [int] = apply fib(a / exh)
                let p : int = #0(p)
                let q : int = #0(q)
                let r : [int] = alloc(I32Add(p,q))
                return(r)        
(*PROMOTE*)
              let kp : cont([int]) = promote(k)
              do UPDATE(0, c, kp)           
   
           let a : [int] = alloc(I32Sub(raw,1))
           let p : [int] = apply fib(a / exh)
	  throw k(p)

  let n : [int] = alloc(n)
  let n : [int] = apply fib (n / exh)
  return(#0(n))
;

define @fib-queue-only (n : int / exh : exh) : int =
  let d : the_deque = @the-new(/exh)

  fun fib (n : [int] / exh : exh) : [int] =
      let raw : int = #0(n)
      if I32Lte(raw, 1)
         then
          let wlit : [int] = alloc(raw)
          return(wlit)
         else
           let raw : int = #0(n)
	   cont k(p : [int]) =
                let a : [int] = alloc(I32Sub(raw,2))
	        let q : [int] = apply fib(a / exh)
                let p : int = #0(p)
                let q : int = #0(q)
                let r : [int] = alloc(I32Add(p,q))
                return(r)           
(*THE*)           
           do @the-push-tl(d, enum(0) / exh)
           let a : [int] = alloc(I32Sub(raw,1))
           let p : [int] = apply fib(a / exh)
           let b : option = @the-pop-tl(d / exh)

	  throw k(p)

  let n : [int] = alloc(n)
  let n : [int] = apply fib (n / exh)
  return(#0(n))
;

define @fib-fls-only (n : int / exh : exh) : int =
  cont k(p : int) = return(1)

  fun fib (n : [int] / exh : exh) : [int] =
      let raw : int = #0(n)
      if I32Lte(raw, 1)
         then
          let wlit : [int] = alloc(raw)
          return(wlit)
         else
           let raw : int = #0(n)
	   cont k(p : [int]) =
                let a : [int] = alloc(I32Sub(raw,2))
	        let q : [int] = apply fib(a / exh)
                let p : int = #0(p)
                let q : int = #0(q)
                let r : [int] = alloc(I32Add(p,q))
                return(r)           
(* FLS*)
  let fgs : fgs = @get-fgs (host_vproc / exh)
 (* initialize the ltc scheduler and return its spawn function *)
  fun init (_ : unit / exh : exh) : any =
      fun f (/exh : exh) : any = return(NIL)
      return(f)
 (* obtain the lazy task queue *)
  let ltqFn : ltq_fun  = @assoc-list-lookup (TAG_LTC, init, fgs / exh)
  let ltq : the_deque = apply ltqFn (/exh)

           let a : [int] = alloc(I32Sub(raw,1))
           let p : [int] = apply fib(a / exh)
	  throw k(p)

  let n : [int] = alloc(n)
  let n : [int] = apply fib (n / exh)
  return(#0(n))
;


define @fib-fbr-only (n : int / exh : exh) : int =
  fun f ( _ : unit / exh : exh) : unit = return(UNIT)
  cont k (_:unit) = return(1)
  let k : fiber = (fiber)k
  let c : ![fiber] = alloc(k)
  let c : ![fiber] = promote(c)

  fun fib (n : [int] / exh : exh) : [int] =
      let raw : int = #0(n)
      if I32Lte(raw, 1)
         then
          let wlit : [int] = alloc(raw)
          return(wlit)
         else
           let raw : int = #0(n)
	   cont k(p : [int]) =
                let a : [int] = alloc(I32Sub(raw,2))
	        let q : [int] = apply fib(a / exh)
                let p : int = #0(p)
                let q : int = #0(q)
                let r : [int] = alloc(I32Add(p,q))
                return(r)           
(*FBIER*)
           let kp : fiber = @fiber(f / exh)
           do UPDATE(0, c, kp)

           let a : [int] = alloc(I32Sub(raw,1))
           let p : [int] = apply fib(a / exh)

	  throw k(p)

  let n : [int] = alloc(n)
  let n : [int] = apply fib (n / exh)
  return(#0(n))
;

extern int GetNumPromotions();
extern int GetTotalPromotionBytes();

define @fib-test-startup ( /exh : exh) : () =
  do @default-scheduler-startup (/exh)

  let b : ml_double = @gettimeofday(UNIT/exh)
  let i : int = @fib-cancel(29 / exh)
  let e : ml_double = @gettimeofday(UNIT/exh)
  let b : double = unwrap(b)
  let e : double = unwrap(e)
  let t : double = F64Sub(e,b)
  let t : ml_double = wrap(t)
  let s : ml_string = @dtos(t / exh)
  let _ : unit = @print(s / exh)
  do ccall M_Print("\n")

  let numPromotions : int = ccall GetNumPromotions()
  let numPromotedBytes : int =  ccall GetTotalPromotionBytes()
  do ccall M_PrintInt(numPromotions)
  do ccall M_PrintInt(numPromotedBytes)

  return()
;
