Some SML code to plot speedup, efficiency, and throughput for benchmarks.  All of
the definitions live in the Graphing module.  This code uses ploticus to do the
actual plotting; see http://ploticus.sourceforge.net for more information.

The input data should be a list of SML records with the following types:

    type benchmark = {
	name : string,		(* name of the benchmark program *)
	size : int,		(* size of the problem; used to compute throughput *)
	date : string,		(* data stamp *)
	comment : string,	(* additional identifying info (e.g., scheduler) *)
	runs : run list		(* list of runs; should include at least a sequential run *)
      }

where

    type run = {
	n : int,		(* number of processors; 0 = sequential implementation *)
	t : real		(* time in seconds *)
      }

The function toBenchmarkInfo is used to compute cumulative information from a list
of benchmark records:

    val toBenchmarkInfo : benchmark list -> cumulative_info

This cumulative information can then be plotted using the following functions

    val speedup    : cumulative_info -> string list -> string -> OS.Process.status
    val times      : cumulative_info -> string list -> string -> OS.Process.status
    val efficiency : cumulative_info -> string list -> string -> OS.Process.status
    val overhead   : cumulative_info -> string list -> string -> OS.Process.status
    val throughput : cumulative_info -> string list -> string -> OS.Process.status

The second argument is a list of ploticus arguments and the third argument is the
output file.  For example,

    speedup (toBenchmarkInfo bmarks) ["-eps"] "speedup.eps"

will generate a speedup plot in EPS format to the file "speedup.eps" from
the benchmark list bmarks.
