(* chan-recv-evt.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Construct a recv event on a channel.
 *)

#include "events.def"

define @chan-acquire-lock (ch : chan / _ : exh) : ();
define @chan-release-lock (ch : chan / _ : exh) : ();
define @event-claim (flg : dirty_flag / exh : exh) : bool;
define @atomic-enqueue (tid : tid, fiber : fiber / exh : exh) : ();
define @chan-dequeue-send (ch : chan / exh : exh) : option;
define @chan-undequeue-send (ch : chan, item : sendq_item / _ : exh) : ();
define @chan-enqueue-recv (ch : chan, flg : dirty_flag, tid : tid, k : cont(any) / _ : exh) : ();

define @chan-recv-evt (ch : chan / _ : exh) : evt =
    fun pollFn (_ : unit / _ : exh) : bool =
	  case CH_GET_SENDQ_HD(ch)
	   of NIL => case CH_GET_SENDQ_TL(ch)
	       of NIL => return (TRUE)
		| _ => return (FALSE)
	      end
	    | _ => return (FALSE)
	  end
  (* attempt to complete the recv operation *)
    fun doFn (resumeK : cont(any) / exh : exh) : unit =
	  do @chan-acquire-lock (ch / exh)
	  let maybeItem : option = @chan-dequeue-send(ch / exh)
	  do @chan-release-lock (ch / exh)
	  (* in *)
	    case maybeItem
	     of NONE => return (UNIT)
	      | SOME(item : sendq_item) =>
		  do @atomic-enqueue (#1(item), #2(item) / exh)
		  throw resumeK (#0(item))
	    end
  (* enqueue the calling thread on the recvq *)
    fun blockFn (arg : [dirty_flag, tid, cont(any)] / exh : exh) : unit =
	  let flg : dirty_flag = #0(arg)
	  let tid : tid = #1(arg)
	  let resumeK : cont(any) = #2(arg)
	  do @chan-acquire-lock (ch / exh)
	  let maybeItem : option = @chan-dequeue-send(ch / exh)
	  (* in *)
	    case maybeItem
	     of SOME(item : sendq_item) =>
		(* there is a matching send, but we must check to make sure
		 * that some other thread has not already claimed this event.
		 *)
		  let success : bool = @event-claim (flg / exh)
		  (* in *)
		    if success then (* we hit the jackpot *)
		      do @chan-release-lock (ch / exh)
		      do @atomic-enqueue (#1(item), #2(item) / exh)
		      throw resumeK (#0(item))
		    else (* the event was claimed, so undo the dequeue *)
		      do @chan-undequeue-send(ch, item / exh)
		      do @chan-release-lock (ch / exh)
		      @thread-exit(/exh)
	      | NONE => (* no luck, so block the receiver *)
		  do @chan-enqueue-recv (ch, flg, tid, resumeK / exh)
		  do @chan-release-lock (ch / exh)
		    return (UNIT)
	    end			    
    let evt : evt = BEVT(pollFn, doFn, blockFn)
    (* in *)
      return (evt)
;
