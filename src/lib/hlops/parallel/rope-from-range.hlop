(* rope-from-leaves.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Creates a balanced rope from range arguments.
 *)

#include "types.def"
#include "ropes.def"

extern void M_Print (void*);

define @rope-from-leaves (leaves : list / exh : exh) : rope;

define @rope-from-range (lo : int, hi : int, gap : int, maxLeafSize : int / exh : exh) : rope =

  let CompilerBug : exn = (exn)enum(0)

  (* divide *)
  (* To split a list into two parts, with the first part having given length. *)
  (* Latter two paramaters are accumulators and should start at 0 and NIL. *)
  (* ex divide ([a,b,c,d,e], 2, 0, NIL) ==> ([a,b], [c,d,e], 2) *)
  (* ex divide ([a,b], 3, 0, NIL) ==> ([a,b], NIL, 2) *)
  (* The last output is the length of the first part, calculted on the fly as a savings. *) 
  fun divide (xs : list, n : int, len : int, acc : list / ) : (list, list, int) =
    if I32Eq (n, 0) then
      let front : list = @list-rev (acc / exh)
      return (front, xs, len)
    else
      case xs
        of NIL => 
             let front : list = @list-rev (acc / exh)
             return (front, NIL, len)
         | CONS (hd : any , tl : list) =>
             let newN : int = I32Sub (n, 1)
             let newAcc : list = CONS (hd, acc)
             let newLen : int = I32Add (len, 1)
             apply divide (tl, newN, newLen, newAcc)
      end (* case *)
  (* end fun divide *)

  (* A function to chop the given list into leaves. *)
  fun chop (ns : list, acc : list / ) : list =
    case ns
      of NIL => @list-rev (acc / exh)
       | CONS (hd : [int], tl : list) =>
           let (front : list, back : list, len : int) = apply divide (ns, maxLeafSize, 0, NIL)
           let lf : rope = LEAF (len, front)		 
           let newAcc : list = CONS (lf, acc)
           apply chop (back, newAcc)
    end (* case *)
  (* end fun chop *)

  (* A function to build the actual list of numbers described by the range. *)
  fun buildList (curr : int, acc : list / ) : list =
    if I32Lt (curr, lo) then
      throw exh (CompilerBug) (* This will only happen if I made a mistake. - ams *)
    else if I32Eq (curr, lo) then
      let w : [int] = wrap(lo)
      return (CONS (w, acc))
    else 
      let next : int = I32Sub (curr, gap)
      let w : [int] = wrap(curr)
      let newAcc : list = CONS (w, acc)
      apply buildList (next, newAcc)
  (* end fun buildList *)

  if I32Gt (lo, hi) then
    return (LEAF (0, NIL))
  else
    let span : int = I32Sub (hi, lo)
    let hiPrime : int = 
      if I32Gt (gap, span) then
        return (lo)
      else
        let t : int = I32Mod (span, gap)
        let u : int = I32Sub (hi, t)
        return (u)
    let nums : list = apply buildList (hiPrime, NIL)
    let leaves : list = apply chop (nums, NIL)
    let r : rope = @rope-from-leaves (leaves / exh)
    return (r)
;

