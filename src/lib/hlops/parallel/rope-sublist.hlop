(* rope-sublist.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Consumes a rope, a start position and a length.
 * Returns a list of data from that position of that length,
 *  and a boolean indicating whether all the data requested was available.
 *
 * That is, if the rope doesn't contain enough data to fulfill the request,
 *  the function returns as much data as it has and false.
 *)

#include "types.def"
#include "ropes.def"
#include "debugging.def"

define @list-append (arg : [list, list] / exh : exh) : list;
define @list-sublist (xs : list, start : int, length : int / exh : exh) : list;

extern void M_Print (void *);
extern void M_PrintInt (int);

define @rope-sublist (r : rope, start : int, len : int / exh : exh) : [list, bool] =

  (* FIXME exn *)
  let Subscript : exn = (exn)enum(0)
  let Length : exn = (exn)enum(0)

  fun rope_len_int (r : rope / ) : int =
    let t : ml_int = @rope-length (r / exh)
    return (unwrap(t))
  (* end fun rope_len_int *)

  (* Invariant: n is not greater than the length of r. *)
  (* FIXME? This allows for bad (too big) start pos with 0 length. *)
  fun sub (r : rope, st : int, n : int / ) : list =
    if I32Eq (n, 0) then return (NIL) else 
    case r
      of LEAF (ml_len:ml_int, data:list) =>
           @list-sublist (data, st, n / exh)
       | CAT (ml_len:ml_int, _:ml_int, r1:rope, r2:rope) =>
           let lenR1 : int = apply rope_len_int (r1)     
           let leftAmt : int = I32Sub(lenR1, st)
           let rightAmt : int = I32Sub(n, leftAmt)
           if I32Lte(n, leftAmt) then
             apply sub (r1, st, n)
           else
             let d1 : list = apply sub (r1, st, leftAmt)
             let d2 : list = apply sub (r2, 0, rightAmt)              
             let tup : [list, list] = alloc (d1, d2)
             @list-append (tup / exh)
    end (* case *)
  (* end fun sub *) 

  if I32Lt (start, 0) then
    do ccall M_Print ("subscript\n\000")
    throw exh (Subscript)
  else if I32Lt (len, 0) then
    do ccall M_Print ("length\n\000")
    throw exh (Length)
  else
    let rLen : int = apply rope_len_int (r)
    let enoughData : bool = I32Lte (len, rLen)
    let data : list =
      if enoughData then
        apply sub (r, start, len)
      else
        apply sub (r, start, I32Sub(rLen, start))
    let result : [list, bool] = alloc (data, enoughData)
    return (result)
;
