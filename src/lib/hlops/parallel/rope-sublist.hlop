(* rope-sublist.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Consumes a rope, a start position and a length.
 * Returns a list of data from that position of that length,
 *  and a boolean indicating whether all the data requested was available.
 *
 * That is, if the rope doesn't contain enough data to fulfill the request,
 *  the function returns as much data as it has and false.
 *)

#include "types.def"
#include "ropes.def"
#include "debugging.def"

define @list-append (arg : [list, list] / exh : exh) : list;
define @list-sublist (xs : list, start : int, length : int / exh : exh) : list;

extern void M_Print (void *);

define @rope-sublist (r : rope, start : int, len : int / exh : exh) : [list, bool] =

  print_ppt()

  fun rope_len_int (r : rope / ) : int =
    print_ppt()
    let t : ml_int = @rope-length (r / exh)
    print_ppt()
    let u : int = unwrap(t)
    return (u)

  print_ppt()

  (* Invariant: n is not greater than the length of r. *)
  fun sub (r : rope, st : int, n : int / ) : list =
    case r
      of LEAF (ml_len:ml_int, data:list) =>
           do ccall M_Print ("@rope-sublist 2\n\000")
           @list-sublist (data, st, n / exh)
       | CAT (ml_len:ml_int, _:ml_int, r1:rope, r2:rope) =>
           do ccall M_Print ("@rope-sublist 3\n\000")
           let lenR1 : int = apply rope_len_int (r1)     
           let leftAmt : int = I32Sub(lenR1, st)
           let rightAmt : int = I32Sub(n, leftAmt)
           if I32Lte(n, leftAmt) then
             apply sub (r1, st, n)
           else
             let d1 : list = apply sub (r1, st, leftAmt)
             let d2 : list = apply sub (r2, 0, rightAmt)              
             let tup : [list, list] = alloc (d1, d2)
             @list-append (tup / exh)
    end (* case *)
  (* end fun sub *) 

  do ccall M_Print ("@rope-sublist 4.1\n\000")
  let rLen : int = apply rope_len_int (r)
  do ccall M_Print ("@rope-sublist 4.2\n\000")
  let longEnough : bool = I32Lte(len, rLen)
  do ccall M_Print ("@rope-sublist 4.3\n\000")
  let data : list =
    (* This check enforces the invariant of the call to sub. *)
    if longEnough then
      do ccall M_Print ("@rope-sublist 5\n\000")
      apply sub (r, start, len)
    else
      do ccall M_Print ("@rope-sublist 6\n\000")
      let available : int = I32Sub(rLen, start)
      apply sub (r, start, available)
  do ccall M_Print ("@rope-sublist 7\n\000")
  let result : [list, bool] = alloc (data, longEnough)
  return (result)
;
