(* rope-sublist.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Consumes a rope, a start position and a length.
 * Returns a list of data from that position of that length,
 *  and a boolean indicating whether all the data requested was available.
 *
 * That is, if the rope doesn't contain enough data to fulfill the request,
 *  the function returns as much data as it has and false.
 *)

#include "types.def"
#include "ropes.def"
#include "debugging.def"

define @list-append (arg : [list, list] / exh : exh) : list;
define @list-sublist (xs : list, start : int, length : int / exh : exh) : list;

extern void M_Print (void *);
extern void M_PrintInt (int);

define @rope-sublist (r : rope, start : int, len : int / exh : exh) : [list, bool] =

  (* FIXME exn *)
  let Subscript : exn = (exn)enum(0)
  let Length : exn = (exn)enum(0)

  fun rope_len_int (r : rope / ) : int =
    let t : ml_int = @rope-length (r / exh)
    return (unwrap(t))
  (* end fun rope_len_int *)

  (* Invariant: n is not greater than the length of r. *)
  (* FIXME? This allows for bad (too big) start pos with 0 length. *)
  fun sub (r : rope, st : int, n : int / ) : list =
    if I32Eq (n, 0) then 
      return (NIL) 
    else 
      case r
        of LEAF (ml_len:ml_int, data:list) =>
             @list-sublist (data, st, n / exh)
         | CAT (ml_len:ml_int, _:ml_int, rL:rope, rR:rope) =>
             let leftLen : int = apply rope_len_int (rL)    
             let allOnLeft : bool = 
               if I32Lt (st, leftLen) then
                 if I32Lt (I32Add (st, n), leftLen) then
                   return (TRUE) 
                 else
                   return (FALSE)
               else
                 return (FALSE)		
             let allOnRight : bool = I32Gte (st, leftLen)
             if allOnLeft then
               apply sub (rL, st, n)
             else if allOnRight then
               apply sub (rR, I32Sub (st, leftLen), n)
             else
               let leftAmt : int = I32Sub (leftLen, st)
               let rightAmt : int = I32Sub (n, leftAmt)
               let d1 : list = apply sub (rL, st, leftAmt)
               let d2 : list = apply sub (rR, 0, rightAmt)
               let tup : [list, list] = alloc (d1, d2)
               @list-append (tup / exh)
      end (* case *)
    (* end if *)
  (* end fun sub *) 

  if I32Lt (start, 0) then
    do ccall M_Print ("subscript\n\000")
    throw exh (Subscript)
  else if I32Lt (len, 0) then
    do ccall M_Print ("length\n\000")
    throw exh (Length)
  else
    let rLen : int = apply rope_len_int (r)
    let enoughData : bool = I32Lte (len, rLen)
    let data : list =
      if enoughData then
        apply sub (r, start, len)
      else
        apply sub (r, start, I32Sub(rLen, start))
    let result : [list, bool] = alloc (data, enoughData)
    return (result)
;
