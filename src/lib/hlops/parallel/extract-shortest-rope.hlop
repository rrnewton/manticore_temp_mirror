(* extract-shortest-rope.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Consumes list of ropes. 
 * Returns a tuple of 3 items:
 * 1. the shortest rope,
 * 2. the list of all other ropes in their original order, and
 * 3. the index of the shortest rope in the original list.
 * NB This hlop is not intended for use in the surface language!
 *    Since it is designed to operate on a list of ropes of mixed types,
 *    the surface laguage wouldn't allow it.
 *)

#include "types.def"
#include "ropes.def"

extern void M_Print (void *);

define @extract-shortest-rope (rs : list / exh : exh) : [rope, list, int] =

  let EmptyListExn : exn = (exn) enum(0)

  (* Exclude the item at position n of given list. *)
  (* 0-based. *)
  (* In the case where n is higher than the highest index, return nil. *)
  fun exclude (xs : list, n : int / ) : list =
    case xs
      of NIL => return (NIL)
       | CONS (hd:any, tl:list) =>
           if I32Eq(n,0) then
             return (tl)
           else
             let next : int = I32Sub(n,1)
             let newTl : list = apply exclude (tl, next)
             return (CONS(hd,newTl))
    end (* case *)
  (* end fun exclude *)

  let original_ropes : list = rs

  (* From a list of ropes, return the shortest rope, the list of other ropes, and
   * the position of the shortest rope in the original list. 
   *
   * The arguments to extr are
   * - ropes, a list of ropes,
   * - minR, the shortest rope seen thus far, 
   * - minN, the length of minR,
   * - minI, the position of minR in the original list, and
   * - curr, the position of the head of ropes in the original list. *)
  fun extr (ropes : list, minR : rope, minN : int, minI : int, curr : int / ) 
                : [rope, list, int] =
    case ropes
      of NIL => 
           let others : list = apply exclude (original_ropes, minI)
           let tup : [rope, list, int] = alloc (minR, others, minI)
           return (tup)
       | CONS (r : rope, rs : list) =>
           let next : int = I32Add(curr,1)
           let rN : int = @rope-length-int (r / exh)
           if I32Lt(rN, minN) then
             apply extr (rs, r, rN, curr, next)
           else
             apply extr (rs, minR, minN, minI, next)
     end (* case *)
   (* end fun extr *)

  case rs 
    of NIL => throw exh (EmptyListExn)
     | CONS (rhd : rope, rtl : list) =>
         let rhdN : int = @rope-length-int (rhd / exh)
         apply extr (rtl, rhd, rhdN, 0, 1)
  end (* case *)
;
