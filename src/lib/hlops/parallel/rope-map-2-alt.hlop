(* rope-map-2-alt.hlop
 *
 * COPYRIGHT (c) 2008 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * This is an instance of the BOM functions that RopeMapMaker is intended to produce.
 *)

#include "types.def"
#include "futures.def"
#include "ropes.def"
#include "debugging.def"

extern void M_Print (void *); (* for debugging *)

define @curried-rope-sublist  (start : int, len : int / exh : exh) : fun (rope / exh -> [list, bool]);
define @extract-shortest-rope (rs : list / exh : exh) : [rope, list, int];
define @future1-spawn (thunk : thunk / exh : exh) : future;
define @insert-at (elt : any, data : list, pos : int / exh : exh) : list;
define @list-map-2 (arg : [fun ([any, any] / exh -> any), list, list] / exh : exh) : list;
define @list-nth (arg : [list, ml_int] / exh : exh) : any;
define @rope-length-int (r : rope / exh : exh) : int;
define @future1-touch (f : future / exh : exh) : any;

define @rope-map-2-alt (args : [fun ([any, any] / exh -> any), rope, rope] / exh : exh) : rope =

  (* FIXME exn *)
  let Length : exn = (exn) enum(0)

  let f : fun ([any, any] / exh -> any) = #0(args)
  let r1 : rope = #1(args)
  let r2 : rope = #2(args)

  fun list_to_tup_2 (k : list / ) : [any, any] = 
    case k
      of CONS (h1 : any, tl : list) =>
           case tl 
             of CONS (h2 : any, tl : list) =>
                  case tl
                    of NIL =>
                         let tup : [any, any] = alloc (h1, h2)
                         return (tup)
                     | CONS (_ : any, _ : list) =>
                         throw exh (Length)
                   end (* case *)
               | NIL => throw exh (Length)
           end (* case *)
      | NIL => throw exh (Length)
    end (* case *)
    (* end fun list_to_tup_2 *)

  let list1 : list = CONS (r2, NIL)
  let ropes : list = CONS (r1, list1)

  let x : [rope, list, int] = @extract-shortest-rope (ropes / exh)
  let s : rope = #0(x)
  let others : list = #1(x)
  let i : int = #2(x)

  (* smap stands for "sequential map" *)
  fun smap2 (f : fun ([any, any] / exh -> any), xs : list, ys : list) : list =
    let arg : [fun ([any, any] / exh -> any), list, list] = alloc (f, xs, ys)
    let res : list = @list-map-2 (arg / exh)
    return (res)
  (* end fun smap2 *)

  fun mapHash1 (xs : list / ) : list = 
    fun hash1 (arg : [list, bool] / exh : exh) : list = 
      let res : list = #0(arg)
      return (res)
    let arg : [fun ([list, bool] / exh -> list), list] = alloc (hash1, xs)
    let ans : list = @list-map (arg / exh)
    return (ans)
  (* end fun mapHash1 *)

  fun rmap2 (shortest : rope, start: int / ) : rope =
    case shortest
      of LEAF (ml_len : ml_int, data : list) =>
           let len : int = unwrap (ml_len)
           let get : fun (rope / exh -> [list, bool]) = 
             @curried-rope-sublist (start, len / exh)
           let othersX : list =
             let arg : [fun (any / exh -> any), list] = alloc (get, others)
             let res1 : list = @list-map (arg / exh)
             let res2 : list = apply mapHash1 (res1)
             return (res2)
           let all : list = @insert-at (data, othersX, i / exh)
           let ds : [any, any] =  apply list_to_tup_2 (all)
           let d1 : list = #0(ds)
           let d2 : list = #1(ds)
           let dataX : list = apply smap2 (f, d1, d2)
           let e : rope = LEAF (ml_len, dataX)
           return (e)
       | CAT (ml_len : ml_int, ml_d : ml_int, shortL : rope, shortR : rope) =>
           let lenL : int = @rope-length-int (shortL / exh)
           let startR : int = I32Add (start, lenL)
           fun thunk (u : unit / exh : exh) : rope = apply rmap2 (shortR, startR)
           let shortRX_F : future = @future1-spawn (thunk / exh)
           let shortLX : rope = apply rmap2 (shortL, start)
           let shortRX : rope = @future1-touch (shortRX_F / exh)
           let c : rope = CAT (ml_len, ml_d, shortLX, shortRX)
           return (c)
    end (* case *)
  (* end fun rmap2 *)

  let answer : rope = apply rmap2 (s, 0)
  return (answer)
;
