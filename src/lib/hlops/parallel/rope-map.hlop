(* rope-map.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * For mapping a function over the elements of the leaves of a rope in parallel.
 *)

#include "types.def"
#include "futures.def"
#include "ropes.def"
#include "debugging.def"

(* use_rw ropes; *)

extern void M_Print(void*);
extern void M_PrintInt(int);

define inline @rope-map (args : [(* f *) fun (any / exh -> any),
                                 (* r *) rope] / exh : exh) : rope =

  print_debug ("=============>>> called rope-map\n\000")
  
  let f : fun (any / exh -> any) = #0(args)
  let r : rope = #1(args)

  fun m (r : rope / ) : rope = 
    case r
      of LEAF(len:int, data:list) => 
           let tup : [fun (any / exh -> any), list] = alloc (f, data)
           let newData : list = @list-map (tup / exh)
           let newLeaf : rope = LEAF(len, newData)
           (* do ccall M_Print("leaf size \000")
           do ccall M_PrintInt(len)
           do ccall M_Print("\n\000") *)
           return (newLeaf)
       | CAT(len:int, depth:int, r1:rope, r2:rope) =>
           fun th (u : unit / exh : exh) : rope = apply m (r2)
           let fut : future = @future1-spawn (th / exh)
           let newR1 : rope = apply m (r1)
           let newR2 : rope = @future1-touch (fut / exh)
           let newR : rope = CAT (len, depth, newR1, newR2)
           return (newR)
    end (* case *)
    (* end definition of m *)

  let newR : rope = apply m (r)
  return (newR)
;
  
        
