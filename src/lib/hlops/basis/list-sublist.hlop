(* list-sublist.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Built-in list sublist function.
 *)

#include "types.def"
#include "debugging.def"

extern void M_Print (void *);
extern void M_PrintInt (int);

define @list-sublist (xs : list, start : int, length : int / exh : exh) : list =

  (* FIXME rewrite with tail calls to improve efficiency *)
  (* INV: start and length are both nonnegative *)
  (* FIXME? This currently allows too-big start pos with length 0. Should it? *)
  fun sub (xs : list, start : int, length : int / ) : list =
    if I32Eq (length, 0) then
      return (NIL)
    else (* length is positive *)
      case xs
        of NIL => (* ran out of elements *)
             let msg : ml_string = @"Length"
             @fail (msg / exh)
         | CONS (hd : any, tl : list) =>
             if I32Gt (start, 0) then
               apply sub (tl, I32Sub(start,1), length)
             else (* start is 0 *)
               let newTl : list = apply sub (tl, start, I32Sub(length,1))
               return (CONS (hd, newTl))
      end (* case *)
  (* end fun sub *)

  if I32Lt (start, 0) then 
    (* negative start pos *)
    do ccall M_Print ("@list-sublist: negative start pos\n\000")
    let msg : ml_string = @"Subscript"
    @fail (msg / exh)
  else if I32Lt (length, 0) then
    (* negative length *)
    do ccall M_Print ("@list-sublist: negative length\n\000")
    let msg : ml_string = @"Length"
    @fail (msg / exh)
  else
    apply sub (xs, start, length)
;
