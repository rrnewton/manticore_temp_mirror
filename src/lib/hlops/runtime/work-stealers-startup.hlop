(* work-stealers-startup.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 * 
 * A top-level work-stealing scheduler for threads.
 *
 * This scheduler implements both a round-robin policy for local threads and a load balancing scheme
 * for distributing threads to other vprocs.  This scheduler uses the protocol below.
 *    (0) Make a list of all other vprocs starting after the current vproc.
 *    (1) If the local vproc queue has a thread ready, run it.
 *    (2) Otherwise, go into steal mode:
 *        (2.1) Send out a thief thread to the first vproc.
 *        (2.2) If a thread is available, put a worker thread back on the original vproc.
 *        (2.3) Otherwise, do the same for the other vprocs.
 *    (3) If the other vprocs have nothing available to steal, add the current vproc to the sleeping list
 *        and go to sleep.
 *    (4) When a preemption arrives, check the local ready queue.  If several unpinned threads are
 *        available, then resuscitate some vprocs.  Then run the next thread in the ready queue.
 * 
 *)

#include "fgs.def"
#include "runtime-offsets.def"
#include "types.def"
#include "vproc-queue.def"

define @scheduler-startup (mkAct : fun (vproc / exh -> sigact), fgs : fgs, vps : list / exh : exh) : ();

(* instantiate a standard spin lock *)
#include "synch/spin-lock-fn.hlop"
define_spin_lock(sl,spin_lock,0)

#include "debugging.def"
#include "assert.def"

extern void *ListVProcs (void *) __attribute__((alloc));
extern void VProcPreempt (void *);

define @work-stealers-startup ( / exh : exh) : () =

  (* fiber-group storage for the top-level scheduler *)
   let wsFGS : fgs = @new-fgs (TRUE, NONE / exh)
  
   fun isUnpinned (fgs : fgs / exh : exh) : bool =
       let pinned : bool = #2(fgs)
       if pinned
          then return (FALSE)
          else return (TRUE)

  (* given a host vproc and a list of vprocs, order those vprocs by the order in which the work stealer 
   * should visit them 
   *)
   fun orderVProcs (self : vproc, vps : list, acc : list / exh : exh) : list = 
       case vps
        of NIL => return (acc)
	 | CONS (vp : vproc, vps : list) =>
           if Equal (vp, self)
              then let arg :[list,list] = alloc (acc, vps)
                   let vprocs : list = @list-append (arg / exh)
                   return (vprocs)
              else apply orderVProcs (self, vps, CONS (vp, acc) / exh)
       end

  (* put schedulers to sleep *)
   let sleepingLock : spin_lock = alloc (FALSE)
   let sleepingLock : spin_lock = promote(sleepingLock)
   let sleeping : ![list] = alloc (NIL)
   let sleeping : ![list] = promote(sleeping)

  (* add the vproc to the sleeping list *)
   fun addToSleeping (vp : vproc / exh : exh) : () =
       fun doit (_ : unit / exh : exh) : unit =
           let rest : list = #0(sleeping)
           let sleepingVProcs : list = CONS (vp, rest)
           let sleepingVProcs : list = promote (sleepingVProcs)
           do #0(sleeping) := sleepingVProcs
           return (UNIT)
       let _ : unit = @with-lock-sl (sleepingLock, doit / exh)
       return ()

  (* given some number of stealable threads, wake at most that many sleeping vprocs *)
   fun wakes (n : int / exh : exh) : list =
       let wakes : ![list] = alloc (NIL)
       let wakes : ![list] = promote(wakes)
       fun doit (_ : unit / exh : exh) : unit =
           fun takeN (i : int, ss : list, rs : list / exh : exh) : list =
               if I32Lte (i, n)
                  then case ss
			of NIL => 
			   do #0(sleeping) := ss
			   return (rs)
			 | CONS (r : vproc, rest : list) =>
                           let rs : list = CONS (r, rs)
			   apply takeN (I32Sub (i,1), rest, rs / exh)
                       end
                  else do #0(sleeping) := ss
		       return (rs)
           let sleepingVProcs : list = #0(sleeping)
           let rs : list = apply takeN (0, sleepingVProcs, NIL / exh)
           let rs : list = promote (rs)
           do #0(wakes) := rs
           return (UNIT)
       let _ : unit = @with-lock-sl (sleepingLock, doit / exh)
       let rs : list = #0(wakes)
       return (rs)

  (* wake any sleeping vprocs if there are stealable threads on the ready queue *)
   fun wakeVProcs (  / exh : exh) : () =
       let stealableFibers : int = @queue-length (isUnpinned / exh)
       if I32Gt(stealableFibers, 0)
          then let rs : list = apply wakes (stealableFibers / exh)
               cont dummyK (u : unit) = 
                    print_debug("dummy")
                    @thread-exit ( / exh)
               fun dispatchOn (vps : list / exh : exh) : () =
                   case vps
		    of NIL => return ()
		     | CONS (vp : vproc, rest : list) =>
                        print_debug("Attempting to wake")
                        do @enqueue-on-vproc (vp, wsFGS, dummyK / exh)
                        apply dispatchOn (rest / exh)
                   end
               do apply dispatchOn (rs / exh)
               return ()
          else return ()

   fun mkWsSwitch (self : vproc / exh : exh) : sigact = 
       let vprocs : list = ccall ListVProcs (self)
      (* (0) *)
       let vprocs : list = apply orderVProcs (self, vprocs, NIL / exh)

       cont wsSwitch (s : signal) =
          let m : bool = vpload (ATOMIC, host_vproc)
          do assert(Equal(m,TRUE))

	  cont dispatch () =
	     let vp : vproc = host_vproc
	     let qitem : rdyq_item = @dequeue (vp / exh)
	     let item : [fgs, fiber, rdyq_item] = ([fgs, fiber, rdyq_item]) qitem
	     let fgs : fgs = #0 (item)
	     let fiber : fiber = #1 (item)
	     @run (vp, wsSwitch, fgs, fiber / exh)

	  (* (2) *)
	  cont steal (vprocs' : list) =
	    case vprocs' 
	      of NIL =>
		     print_debug("Thief is giving up on all vprocs")
		    (* (3) *)
		     do apply addToSleeping (self / exh)
		     @thread-exit ( / exh)
	       | CONS (vp : vproc, vprocs' : list) => 
		    (* (2.1) *)
		     print_debug("Sending thief to vproc")
		     cont thiefFiber (x : unit) = 
			print_debug("Thief fiber")
		        let hasElts : bool = @is-queue-gt-one ( / exh)
		        if hasElts
			   then (* (2.2) *)
			        print_debug("Stealing a remote thread")
			        let qitemOpt : option = @dequeue-with-pred (host_vproc, isUnpinned / exh)
			        case qitemOpt
  				 of NONE => 
				    print_debug("Nothing to steal on this vproc")
			            throw steal (vprocs')
				  | SOME (qitem : rdyq_item) =>
                                    print_debug("Stole a thread")
				    let item : [fgs, fiber, rdyq_item] = ([fgs, fiber, rdyq_item]) qitem
				    let fgs : fgs = #0 (item)
				    let fiber : fiber = #1 (item)
				    do @enqueue-on-vproc (self, fgs, fiber / exh)
				   (* Wake up the vproc *)
				    do ccall VProcPreempt (self)
				    @thread-exit (/ exh)
			        end
			else (* (2.3) *)
			     print_debug("Thief is giving up on this vproc")
			     throw steal (vprocs')
		    do @enqueue-on-vproc (vp, wsFGS, thiefFiber / exh)
		    throw dispatch ()
	    end

	(* signal handling *)      
	if Equal (s, STOP) 
	   then let qEmpty : bool = @is-queue-empty ( / exh)
		if qEmpty
		   then throw steal (vprocs)
		   else (* (1) *)
			throw dispatch ()
	   else let fid : fid = @get-fid (self / exh)
		let k : fiber = (fiber)s
		let fgs : fgs = @get-fgs (self / exh)
		do @enqueue (host_vproc, fgs, k / exh)
	       (* (4) *)
		do apply wakeVProcs ( / exh)
		throw dispatch ()

     return (wsSwitch)

  (* get handles for all vprocs *)
   let vps : list = ccall ListVProcs(host_vproc)
  (* install the scheduler on all vprocs *)
   do @scheduler-startup (mkWsSwitch, wsFGS, vps / exh)
   return ()
;
