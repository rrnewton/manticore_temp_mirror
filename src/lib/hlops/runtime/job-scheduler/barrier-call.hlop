(* barrier-call.hlop
 * 
 * COPYRIGHT (c) 2008 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Synchronize a group of fibers on a barrier and then call a finish continuation.  The barrier
 * is reentrent.
 *)

#include "barrier-call.def"
#include "debugging.def"
#include "fgs.def"
#include "logging.def"
#include "assert.def"

define @barrier-call (bc : barrier_call, arg : any / exh : exh) : () =

 (* add elt to the barrier arguments *)
  fun addArg () : () =
      let oldArgs : list = SELECT(ARGU_OFF, bc)
      let args : list = CONS(arg, oldArgs)
      let args : list = promote(args)
      let args' : list = CAS(&2(bc), oldArgs, args)  (* &ARGU_OFF(bc) *)
      if Equal(oldArgs, args')
         then return()
         else apply addArg()

  let i : int = I32FetchAndAdd(&COUNTER_OFF(bc), 1)
  let n : int = SELECT(N_OFF, bc)
  do apply addArg()
  if I32Lt(i, I32Sub(n,1))
     then (* other fibers need to call the barrier; so exit *)
           return()
     else (* this fiber is the last to call the barrier; so it will invoke the continuation *)
           do UPDATE(COUNTER_OFF, bc, 0)               (* reset the barrier *)
           let args : list = SELECT(ARGU_OFF, bc)
           do UPDATE(ARGU_OFF, bc, NIL)
           let k : cont(list) = SELECT(CONT_OFF, bc)
           do assert(NotEqual(k, NIL))
           throw k(args)

;
