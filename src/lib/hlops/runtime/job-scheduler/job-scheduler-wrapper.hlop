(* job-scheduler-wrapper.hlop
 * 
 * COPYRIGHT (c) 2008 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Wraps a fiber in another fiber that handles job scheduling.
 *)

#include "job-scheduler.def"
#include "tags.def"
#include "debugging.def"
#include "fgs.def"
#include "logging.def"
#include "scheduling-ops.def"

define @job-scheduler-wrapper (fgs : fgs,                                    (* fgs for the job *)
                               mkAct : fun (vproc / exh -> sigact),          (* get a new scheduler instance *)
                               jobScheduler : job_scheduler,                 (* job scheduler *)
			       k : fiber                                     (* initial fiber *)
			       / exh : exh) : unit =

  let upcallJobSched : cont(desire_req) = SELECT(0, jobScheduler)
  let addJob : fun(/-> option) = SELECT(1, jobScheduler)

  (* create the job *)
  let retOpt : option = apply addJob()
  let ret : [job_id, vproc] = case retOpt
			       of NONE => throw exh(tag(noJob))
				| SOME(ret : [job_id, vproc]) =>
				  return(ret)
                               end

  (* barrier call for the job *)
  cont dummy (x : list) = @thread-exit(/exh)
  let bc : barrier_call = @barrier-call-new(dummy / exh)
  cont upcallSched (desire : desire) =
       do @barrier-call(bc, desire / exh)
       @thread-exit(/exh)
  (* add the first worker *)
  ADD_CALLER(bc)

  fun initScheduler (wrapper : sigact, vp : vproc / exh : exh) : () =
      (* start the scheduler *)
      cont startup (_ : unit) =
           (* wrap the calling fiber *)
           let _ : any = @assoc-list-add(tag(addJob), addJob, fgs / exh)
           let act : sigact = apply mkAct (host_vproc / exh)
          @run (host_vproc, act, fgs, k / exh)

         (* wrap the scheduler in the job scheduler *)
         cont wrappedSched (_ : unit) =
             let startup : fiber = (fiber)startup       
         @run (host_vproc, wrapper, fgs, startup / exh)

      let wrappedSched : fiber = (fiber)wrappedSched
      do @enqueue-on-vproc(vp, fgs, wrappedSched /exh)
      return()

  (* wrapper for the worker *)
  cont wrapper (s : signal) = 

(*FIXME!*)
  (* the workers upcall here so that the job can then upcall into the job scheduler. *)
  cont workers (changeDesires : list) =
       fun resumeWorkers (changeDesires : list / exh : exh) : () =
	   case changeDesires
	    of NIL => return()
	     | CONS(desire : desire, changeDesires : list) =>
	       do @enqueue-on-vproc(SELECT(JS_WORKER_VPROC_OFF, desire), 
				    fgs,
				    SELECT(JS_WORKER_RESUMEK_OFF, desire) / exh)
	       apply resumeWorkers (changeDesires / exh)
           end
       (* get the allotment from the job server and resume the active workers *)
       cont getAllotment (allotment : list) =

            fun initNewSchedulers (allotment : list / exh : exh) : () =
		case allotment
		 of NIL => return()
		  | CONS(vp : [vproc], allotment : list) =>
print_msg("inits")
                    do apply initScheduler (wrapper, SELECT(0, vp) / exh)
                    apply initNewSchedulers (allotment / exh)
                end
            
            print_msg("getallotment")
            do apply initNewSchedulers (allotment / exh)
            do apply resumeWorkers (changeDesires / exh)
            @thread-exit(/exh)
       let desireReq : desire_req = alloc(host_vproc, 0, 0, 0, fgs, getAllotment)
       throw upcallJobSched(desireReq)

  (*FIXME*)
  let workers : cont(list) = promote(workers)
  do UPDATE(CONT_OFF, bc, workers)

       let fgs : fgs = @get-fgs(host_vproc/exh)
       let k : fiber = (fiber)s
       let desire : option = @assoc-list-query(tag(desire), fgs / exh)

       cont dispatch (k : fiber) =
            @run(host_vproc, wrapper, fgs, k / exh)

       do case desire
	   of NONE => return()
	    | SOME (changeDesire : desire) =>
              cont resume (_ : unit) = throw dispatch (SELECT(JS_WORKER_RESUMEK_OFF, changeDesire))
              let changeDesire : desire = alloc(SELECT(JS_WORKER_DESIRE_OFF, changeDesire), 
						SELECT(JS_WORKER_VPROC_OFF, changeDesire), 
						resume,
						SELECT(JS_WORKER_EXIT_OFF, changeDesire))
              throw upcallSched(changeDesire)
           end

       if Equal(s, STOP) 
	  then @thread-exit(/exh)
          else let _ : unit = @atomic-yield(host_vproc / exh)
	       throw dispatch(k)

  do apply initScheduler (wrapper, SELECT(1, ret) / exh)
  return(UNIT)
;
