(*
 * Run me by saying
 *    mc -Cdebug=true -Cscheduler=future1-test triv.pml
 *) 

#include "futures.def"
#include "testing.def"
#include "vproc-queue.def"
#include "runtime-offsets.def"
#include "scheduler-ops.def"

define @fib (n : int / exh : exh) : int =
  fun fib (n : int / ) : int =
      if I32Lte(n,1)
         then return(n)
         else let p : int = apply fib(I32Sub(n,1) /)
              let q : int = apply fib(I32Sub(n,2) /)
              return(I32Add(p,q))
  apply fib (n /)
;

(*
define @test-cancel ( / exh : exh) : bool =
  let done : ![bool] = alloc(TRUE)
  let done : ![bool] = promote(done)

  let flg : ![bool] = alloc(FALSE)
  let flg : ![bool] = promote(flg)

  fun loop1(i : long/exh : exh) : () =
      if I64Eq(i,0)
	 then do UPDATE(0, done, TRUE)
              return()
         else do UPDATE(0, done, FALSE)
              let _ : unit = @wait(1.0:double, done /exh)
              apply loop1(I64Sub(i,1)/exh)

  fun loop2(i : long/exh : exh) : () =
      if I64Eq(i,0)
	 then return()
         else apply loop2(I64Sub(i,1)/exh)


  fun f (_ : unit / exh : exh) : unit =
     print_msg("f")
     (* loop for ~10 secs *)
      do loop1 (10 /exh)      
      return (UNIT)

  let fut : future = @future1-spawn(f / exh)
 (* wait for fut to start evaluating *)
  do loop2(10000:long / exh)
 (* cancel fut *)
  let _ : unit = @future1-cancel(fut / exh)
 (* wait for the scheduler to drop fut *)
  let _ : unit = @wait(1.0:double, flg /exh)
 (* make sure that fut did not finish *)
  let doneFlg : bool = SELECT(0, done)
  return(BNot(doneFlg))
;
*)

define @test1 (/ exh : exh) : bool =
  let n : int = 31
  fun f (_ : unit / exh : exh) : [int] =
      let x : int = @fib(n / exh)
      let wx : [int] = wrap(x)
      return(wx)

  let fut : future = @future1-spawn(f / exh)  
  let ans1 : int = @fib(n / exh)
  let ans2 : any = @future1-touch(fut / exh)
  let ans2 : [int] = ([int])ans2
  return(I32Eq(ans1, unwrap(ans2)))
;

define @future1-test-startup ( /exh : exh) : () =
  do @default-scheduler-startup (/exh)

  do_concurrent_test(test1, 5.0:double)

  return ()
;