(* future1-spawn.hlop
 * 
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Spawn a one-toucher future.
 *)

#include "types.def"
#include "futures.def"
#include "runtime-offsets.def"
#include "tags.def"
#include "fgs.def"
#include "logging.def"
#include "debugging.def"

define @future1-work-sharing ( / exh : exh) : locked_queue;

define @future1-spawn (thunk : thunk / exh : exh) : future =  
 (* get the fiber-group storage of the caller *)
  let parentFGS : fgs = @get-fgs (host_vproc / exh)

 (* create fgs for the future *)
  let fgs : fgs = @new-fgs (TRUE, SOME (parentFGS) / exh)

 (* create the cancel cell for the future *)
  let cancelCell : cancel_cell = @cancel-cell(/exh)
  let cancelCell : cancel_cell =  @assoc-list-add(TAG_CANCEL_CELL_FUTURE1, cancelCell, fgs / exh)

  let fut : future = alloc (EMPTY_F, thunk, cancelCell, fgs)
  let fut : future = promote (fut)

 (* initialize the children list *)
  let children : ![list] = alloc(NIL)
  let children : ![list] =  @assoc-list-add(TAG_CHILD_FUTURES1, children, parentFGS / exh)  
 (* add a future to a children list *)
  fun addChild (children : ![list], fut : future / exh : exh) : () =
      let childrenL : list = SELECT(0, children)
      let childrenL : list = CONS(fut, childrenL)
      let childrenL : list = promote(childrenL)
      do UPDATE(0, children, childrenL)
      return()
 (* add the future to the children of the calling thread *)
  do apply addChild (children, fut / exh)

 (* clean up if the future is cancelled *)
  fun cleanupFun (/ exh : exh) : () = 
      fun kill (childrenL : list / exh : exh) : () =
	  case childrenL
	   of NIL => return()
	    | CONS(child : future, children : list) =>
	      let _ : unit = @future1-cancel(child /exh)
	      apply kill(children / exh)
          end
      apply kill(SELECT(0, children) / exh)

  (* initialize the futures scheduler and return its spawn function *)
  fun initSched (_ : unit / exh : exh) : any =
      let futuresQ : locked_queue = @future1-work-sharing ( / exh)
      return (futuresQ)
  (* obtain the futures queue *)
  let futuresQ : locked_queue = @assoc-list-lookup (TAG_SPAWN_FUTURE1, initSched, parentFGS / exh)

 (* create the fiber for evaluating the future *)
  fun wrapper (_ : unit / exh : exh) : unit =
      do @future1-steal (futuresQ, fut / exh)
      return (UNIT)
  let k : fiber = @fiber (wrapper / exh)
  let k : fiber = @cancellable-fiber(cancelCell, fgs, k, cleanupFun / exh)
 (* add the future to the scheduling queue *)
  do @locked-queue-enqueue (futuresQ, k / exh)

 (* log the spawn *)
  do LOG_PTR(RTFuture1SpawnEvt, fut)

  return (fut) 
;
