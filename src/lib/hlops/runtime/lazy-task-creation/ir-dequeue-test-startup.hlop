(*
 * Run me by saying
 *    mc -Cdebug=true -Cscheduler=ir-dequeue-test triv.pml
 *) 

#include "ir-dequeue.def"
#include "./ir-dequeue.hlop"
#include "testing.def"
#include "vproc-queue.def"
#include "runtime-offsets.def"

define @test-dq-1 (/ exh : exh) : bool =  
  cont exit () = return (FALSE)
  fun buildLs (i : int / ) : list =
      fun f (a : ml_int / exh : exh) :any = return (a)
      let lo : ml_int = wrap(0)
      let hi : ml_int = wrap(i)
      let step : ml_int = wrap(1)
      let a : [(* f *) fun (ml_int / exh -> any), 
               (* ml_lo *) ml_int,
                           (* ml_hi *) ml_int,
                          (* ml_step *) ml_int] = alloc (f, lo, hi, step)
      @list-tab(a / exh)

  fun checkFn (check : fun(int, int / exh -> bool), prev : int, max : int, ls : list / exh : exh) : () =
      case ls
       of NIL => return ()
	| CONS (x: ml_int, xs : list) =>
	  let x : int = unwrap(x)
          let b : bool = apply check (x, prev / exh)
          if NotEqual(b,TRUE)
             then throw exit()
          else if I32Gt(x,max)
             then throw exit()
          else apply checkFn (check, x, max, xs/ exh)
      end

  fun toList (deq : ir_dequeue, ls : list /) : list =
      cont none () = return (ls)
      cont some (x : any) = 
           let ls' : list = CONS(x, ls)
           apply toList (deq, ls' /)
      do @ird-pop-hd (deq, none, some / exh)
      throw exit()
  fun toListRev (deq : ir_dequeue, ls : list /) : list =
      cont none () = return (ls)
      cont some (x : any) = 
           let ls' : list = CONS(x, ls)
           apply toListRev (deq, ls' /)
      do @ird-pop-tl (deq, none, some / exh)
      throw exit()
  fun fromList (deq : ir_dequeue, ls : list / ) : () =
      case ls
       of NIL => return ()
	| CONS (x : any, xs : list) =>
          let elt : ir_dequeue_elt = IR_DEQUEUE_NEW(x)
	  do @ird-push-hd(deq, elt / exh)
          apply fromList (deq, xs)
      end

  let nElts : int = 300
  let deq : ir_dequeue = alloc(IR_DEQUEUE_EMPTY,IR_DEQUEUE_EMPTY)

  fun checkInc (x : int, prev : int / exh : exh) : bool =
      let b : bool = I32Gt(x,prev)
      return (b)
  fun checkDec (x : int, prev : int / exh : exh) : bool =
      let b : bool = I32Lt(x,prev)
      return (b)
  
  let ls0 : list = apply buildLs (nElts/ )
  do apply fromList(deq, ls0)
  let lsInc : list = apply toList(deq, NIL /)
  do apply checkFn(checkInc, -1, I32Add(nElts,1), lsInc / exh)

  let ls0 : list = apply buildLs (nElts/ )
  do apply fromList(deq, ls0)
  let lsInc : list = apply toListRev(deq, NIL /)
  do apply checkFn(checkDec, I32Add(nElts,1), I32Add(nElts,1), lsInc / exh)

  return(TRUE)
;

define @work-stealers-startup ( / exh : exh) : ();

define @ir-dequeue-test-startup ( /exh : exh) : () =
  do @work-stealers-startup (/ exh)
  do_test(test-dq-1)
  return ()
;
