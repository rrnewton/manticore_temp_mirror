(*
 * Run me by saying
 *    mc -Cdebug=true -Cscheduler=ir-dequeue-test triv.pml
 *) 

#include "ir-dequeue.def"
#include "testing.def"
#include "vproc-queue.def"
#include "runtime-offsets.def"

define @test-dq-1 (/ exh : exh) : bool =  
  cont exit () = return (FALSE)
  fun buildLs (i : int / ) : list =
      fun f (a : ml_int / exh : exh) :any = return (a)
      let lo : ml_int = wrap(0)
      let hi : ml_int = wrap(i)
      let step : ml_int = wrap(1)
      let a : [(* f *) fun (ml_int / exh -> any), 
               (* ml_lo *) ml_int,
                           (* ml_hi *) ml_int,
                          (* ml_step *) ml_int] = alloc (f, lo, hi, step)
      @list-tab(a / exh)

  fun checkFn (check : fun(int, int / exh -> bool), prev : int, max : int, ls : list / exh : exh) : () =
      case ls
       of NIL => return ()
	| CONS (x: ml_int, xs : list) =>
	  let x : int = unwrap(x)
          let b : bool = apply check (x, prev / exh)
          if NotEqual(b,TRUE)
             then throw exit()
          else if I32Gt(x,max)
             then throw exit()
          else apply checkFn (check, x, max, xs/ exh)
      end

  fun toList (nElts: int, deq : ir_dequeue, ls : list /) : list =
      cont exit () = return (ls)
      do if I32Lt(nElts, 0)
            then throw exit ()
            else return()
      let xOpt : option = @ird-pop-hd (deq / exh)
      case xOpt
       of NONE => throw exit ()
	| SOME(x : [int]) =>
          let ls' : list = CONS(x, ls)
          apply toList (I32Sub(nElts,1), deq, ls' /)      
      end
  fun toListRev (nElts: int, deq : ir_dequeue, ls : list /) : list =
      cont exit () = return (ls)
      do if I32Lt(nElts, 0)
            then throw exit ()
            else return() 
      let xOpt : option = @ird-pop-tl (deq / exh)
      case xOpt
       of NONE => throw exit ()
	| SOME(x : [int]) =>
          let ls' : list = CONS(x, ls)
          apply toListRev (I32Sub(nElts,1), deq, ls' /)      
      end
  fun fromList (deq : ir_dequeue, ls : list / ) : () =
      case ls
       of NIL => return ()
	| CONS (x : any, xs : list) =>
          let elt : ir_dequeue_elt = IR_DEQUEUE_NEW(x)
	  do @ird-push-hd(deq, elt / exh)
          apply fromList (deq, xs)
      end

  let nElts : int = 10
  let deq : ir_dequeue = IR_DEQUEUE()

  fun checkInc (x : int, prev : int / exh : exh) : bool =
do ccall M_PrintInt(x)
      let b : bool = I32Gt(x,prev)
      return (b)
  fun checkDec (x : int, prev : int / exh : exh) : bool =
(*do ccall M_PrintInt(prev)*)
do ccall M_PrintInt(x)
      let b : bool = I32Lt(x,prev)
      return (TRUE)
  
  let ls0 : list = apply buildLs (nElts/ )
(*
  do apply fromList(deq, ls0)
  let ls : list = apply toList(nElts, deq, NIL /)
  do apply checkFn(checkInc, -1, I32Add(nElts,1), ls / exh)
*)

(*  let ls : list = apply toListRev(nElts, deq, NIL /)
  do apply checkFn(checkDec, I32Add(nElts,1), I32Add(nElts,1), ls / exh)
*)

  do apply fromList(deq, ls0)
  let ls : list = apply toList(I32Div(nElts,2), deq, NIL /)
  do apply checkFn(checkInc, I32Sub(I32Div(nElts,2),1), I32Add(nElts, 1), ls / exh)  
print_msg("")
  let ls : list = apply toListRev(I32Div(nElts,2), deq, NIL /)
  do apply checkFn(checkDec, I32Div(nElts,2), I32Add(nElts,1), ls / exh)

  return(TRUE)
;

define @work-stealers-startup ( / exh : exh) : ();

define @ir-dequeue-test-startup ( /exh : exh) : () =
  do @work-stealers-startup (/ exh)
  do_test(test-dq-1)
  return ()
;
