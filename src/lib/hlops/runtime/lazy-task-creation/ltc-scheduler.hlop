(* ltc-scheduler.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Scheduler for lazy task creation.
 *)

#include "ltc.def"
#include "fgs.def"
#include "types.def"
#include "runtime-offsets.def"
#include "debugging.def"
#include "assert.def"
#include "array.def"

extern void *ListVProcs (void *) __attribute__((alloc));

(* returns a random number within lower and upper bounds *)
define inline @rand-int(lo : int, hi : int / exh : exh) : int =
  let lo : ml_double = wrap(I32ToF64(lo))
  let hi : ml_double = wrap(I32ToF64(hi))
  let arg : [ml_double, ml_double] = alloc(lo, hi)
  let r : ml_double = @drand (arg / exh)
  let r : double = unwrap(r)
  let r : int = F64ToI32(r)
  return (r)
;

define inline @vproc-id(/ exh: exh) : int =
  let vpId : int = vpload(VPROC_ID, host_vproc)
  return(vpId)
;

define @ltc-scheduler ( / exh : exh) : ltq_fun =
  let vps : list = ccall ListVProcs(host_vproc)  
  let nVProcs : ml_int = @list-length(vps /exh)

  let arg : [ml_int, any] = alloc(nVProcs, enum(0))
 (* ltqTbl maps from vproc ids to lazy task queues *)
  let ltqTbl : array = @array(arg / exh)
  fun mkVPTbl (i : int / exh : exh) : () =
      if I32Lt(i, unwrap(nVProcs))
         then let ltq : the_deque = @the-new(/exh)
              do @array-update-ub(ltqTbl, i, ltq / exh)
              apply mkVPTbl(I32Add(i, 1) / exh)
         else return()
  do apply mkVPTbl(0 / exh)

 (* make the lazy task queue accessible to fibers. we use a lookup function, since computations
  * must obtain access to the lazy task queues of their own vprocs.
  *)
  fun ltqFn (/exh : exh) : the_deque = 
      let vpId : int = @vproc-id(/exh)
      @array-sub-ub(ltqTbl, vpId / exh)

 (* Initialize fiber-group storage. *)
  let parentFGS : fgs = @get-fgs (host_vproc / exh)

  (* for experimentation purposes *)
  let nFinished : ![int] = alloc(0)
  let nFinished : ![int] = promote(nFinished)

  fun mkSwitch (self : vproc / exh : exh) : sigact =

      let fgs : fgs = @new-fgs (TRUE, SOME (parentFGS) / exh)
     (* add the spawn function to the fiber group storage *)
      fun init (_ : unit / exh : exh) : any = return (ltqFn)
      let _ : any = @assoc-list-lookup (TAG_LTC, init, fgs / exh)

      fun init (_ : unit / exh : exh) : any = return (nFinished)
      let _ : any = @assoc-list-lookup(tag(allStealing), init, fgs / exh)
      fun stealMode () : () = 
	  let _ : int = I32FetchAndAdd(&0(nFinished), 1)
          return()                    
      fun workMode () : () = 
	  let _ : int = I32FetchAndAdd(&0(nFinished), -1)
          return()                    

      let vpId : int = @vproc-id(/exh)
      let selfLtq : the_deque = @array-sub-ub(ltqTbl, vpId / exh)
      cont switch (s: signal) =
           cont dispatch (k : fiber) =
                @run(self, switch, fgs, k / exh)

          (* try to steal a frame from one of the other vprocs. *)
           cont steal () =
                let victimId : int = @rand-int(0, I32Sub(unwrap(nVProcs), 1) /exh)
                let victimLtq : the_deque = @array-sub-ub(ltqTbl, victimId / exh) 
                let kOpt : option = @the-pop-hd(victimLtq / exh)
                case kOpt
		 of NONE => 
		    let _ : unit = @atomic-yield(self / exh)
		    throw steal()
		  | SOME(k : fiber) => 
                    do assert(NotEqual(k, enum(0)))
                    do apply workMode()
		    throw dispatch (k)
                end

           if Equal(s, STOP)
              then let kOpt : option = @the-pop-tl(selfLtq / exh)
                   case kOpt
		    of NONE => 
                       do apply stealMode()
		       throw steal()
		     | SOME(k : fiber) => throw dispatch(k)
                   end
              else let _ : unit = @atomic-yield(self / exh)
                   let k : fiber = (fiber)s
                   throw dispatch(k)
      return(switch)

  do @scheduler-startup (mkSwitch, parentFGS, vps / exh)

  return (ltqFn)
;

