(* ltc-scheduler.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Scheduler for lazy task creation.
 *)

#include "ltc.def"
#include "fgs.def"
#include "types.def"
#include "runtime-offsets.def"
#include "debugging.def"
#include "assert.def"

extern void *ListVProcs (void *) __attribute__((alloc));

(* returns a random number within lower and upper bounds *)
define @rand-int(lo : int, hi : int / exh : exh) : int =
  let lo : ml_double = wrap(I32ToF64(lo))
  let hi : ml_double = wrap(I32ToF64(hi))
  let r : ml_double = @drand (lo, hi / exh)
  let r : double = unwrap(r)
  let r : int = F64ToI32(r)
  return (r)
;

(* pick an element uniformly at random from the list *)
define @pick-random-elt(ls : list / exh : exh) : any =
  let len : ml_int = @list-length(ls /exh)
  let r : int = @rand-int(0, I32Sub(unwrap(len), 1) / exh)
  let r : ml_int = wrap(r)
  let arg : [list, ml_int] = alloc(ls, r)
  let elt : any = @list-nth(arg / exh)
  return (elt)
;

define @wrap-vps(vps : list / exh : exh) : list =
  fun loop (vps : list, wvps : list) : list =
      case vps
       of NIL => return(wvps)
	| CONS(vp : vproc, vps : list) => 
	  let wvp : [vproc] = alloc(vp)
	  apply loop(vps, CONS(wvp, wvps))
       end
  apply loop (vps, NIL)
;

define @ltc-scheduler ( / exh : exh) : ltq_fun =

  let vps : list = ccall ListVProcs(host_vproc)
  let vps' : list = @wrap-vps(vps / exh)

 (* create a mapping from vprocs to their lazy task queues. *)
  fun mkLtqMp (vps : list, mp : list / exh : exh) : list =
      case vps
       of NIL => return(mp)
	| CONS(vp : vproc, vps : list) =>
          let ltq : ir_dequeue = IR_DEQUEUE()
          let elt : [vproc, ir_dequeue] = alloc(vp, ltq)
	  apply mkLtqMp(vps, CONS(elt, mp) / exh)
      end
  let vpLtqMp : list = apply mkLtqMp(vps, NIL / exh)
  let vpLtqMp : list = promote(vpLtqMp)

 (* find the lazy task queue for a vproc. *)
  fun findLtq (vp : vproc, ltqAlist : list / exh : exh) : ir_dequeue =
      case ltqAlist
       of NIL => 
	  do assert(FALSE)
	  throw exh(tag(findAtq))
	| CONS(vpLtq : [vproc, ir_dequeue], rest : list) =>
	  if Equal(vp, #0(vpLtq))
             then return (#1(vpLtq))
             else apply findLtq (vp, rest / exh)
      end

 (* make the lazy task queue accessible to fibers. we use a lookup function, since computations
  * must obtain access to the lazy task queues of their own vprocs.
  *)
  fun ltqFn (/exh : exh) : ir_dequeue = 
      apply findLtq (host_vproc, vpLtqMp / exh)

 (* Initialize fiber-group storage. *)
  let parentFGS : fgs = @get-fgs (host_vproc / exh)
  let fgs : fgs = @new-fgs (TRUE, SOME (parentFGS) / exh)
 (* add the spawn function to the fiber group storage *)
  fun init (_ : unit / exh : exh) : any = return (ltqFn)
  let _ : any = @assoc-list-lookup (TAG_LTC, init, fgs / exh)

  fun popTl (ltq : ir_dequeue / exh : exh) : option =      
      let mask : bool = @spin-lock-ird (ltq / exh)
        let elt : option = @ird-pop-tl(ltq / exh)
      let _ : unit = @spin-unlock-ird (ltq, mask / exh)
      return(elt)

  fun popHd (ltq : ir_dequeue / exh : exh) : option =      
      let mask : bool = @spin-lock-ird (ltq / exh)
        let elt : option = @ird-pop-hd(ltq / exh)
      let _ : unit = @spin-unlock-ird (ltq, mask / exh)
      return(elt)

  fun mkSwitch (self : vproc / exh : exh) : sigact =
      let selfLtq : ir_dequeue = apply findLtq (self, vpLtqMp / exh)      
      cont switch (s: signal) =
           cont dispatch (k : fiber) =
                @run(self, switch, fgs, k / exh)

          (* try to steal a frame from one of the other vprocs. *)
           cont steal () =
                let victim : any = @pick-random-elt(vps' / exh)
                let victim : [vproc] = ([vproc])victim
                do if Equal(#0(victim), self)
                      then throw steal()
                      else return()
                let victimLtq : ir_dequeue = apply findLtq (#0(victim), vpLtqMp / exh)
                let kOpt : option = apply popTl (victimLtq / exh)
                case kOpt
		 of NONE => 
		    let _ : unit = @atomic-yield(self / exh)
		    throw steal()
		  | SOME(k : fiber) => 
		    throw dispatch (k)
                end

           if Equal(s, STOP)
              then let kOpt : option = apply popHd(selfLtq / exh)
                   case kOpt
		    of NONE => throw steal()
		     | SOME(k : fiber) => throw dispatch(k)
                   end
              else let _ : unit = @atomic-yield(self / exh)
                   let k : fiber = (fiber)s
                   throw dispatch(k)
      return(switch)

  do @scheduler-startup (mkSwitch, fgs, vps / exh)

  return (ltqFn)
;

