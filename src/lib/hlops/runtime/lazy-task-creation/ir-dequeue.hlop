#include "types.def"
#include "runtime-offsets.def"
#include "ir-dequeue.def"

define @ird-push-hd(deq : ir_dequeue, elt : ir_dequeue_elt / exh : exh) : () =
  let oldHd : ir_dequeue_elt = SELECT(IR_DEQUEUE_HD, deq)
 (* point the new head element to the old one *)
  let oldHd1 : any = (any)oldHd
  do UPDATE (IR_DEQUEUE_ELT_NEXT, elt, oldHd1)  
  let empty : any = (any)IR_DEQUEUE_EMPTY
 (* initialize the new head *)
  do UPDATE (IR_DEQUEUE_ELT_PREV, elt, empty)  
  do if NotEqual(oldHd, IR_DEQUEUE_EMPTY)
        then 
            (* redirect the old hd to the new hd *)
             let elt : any = (any)elt
             do UPDATE(IR_DEQUEUE_ELT_PREV, oldHd, elt)
             return ()
        else 
             (* the stack is empty; point the tail to the element. *)
             do UPDATE(IR_DEQUEUE_TL, deq, elt)
             return ()
 (* update the stack head *)
  do UPDATE(IR_DEQUEUE_HD, deq, elt)  
  return ()
;

define @ird-pop-hd(deq : ir_dequeue, none : cont(), some : cont(any) / exh : exh) noreturn =
  let oldHd : ir_dequeue_elt = SELECT(IR_DEQUEUE_HD, deq)
 (* exit if the dequeue is empty *)
  do if Equal(oldHd, IR_DEQUEUE_EMPTY)
        then throw none ()
        else return ()
  let nextHd : ir_dequeue_elt = SELECT(IR_DEQUEUE_ELT_NEXT, oldHd)
 (* update the next head element's prev pointer *)
  do if Equal(nextHd, IR_DEQUEUE_EMPTY)
     then return ()
     else let empty : any = (any)IR_DEQUEUE_EMPTY
          do UPDATE(IR_DEQUEUE_ELT_PREV, nextHd, empty)
          return () 
 (* update the stack head *)
  do UPDATE(IR_DEQUEUE_HD, deq, nextHd)
 (* return the element *)
  let elt : any = SELECT(IR_DEQUEUE_ELT_DATA, oldHd)
  throw some(elt)
;

define @ird-pop-tl(deq : ir_dequeue, none : cont(), some : cont(any) / exh : exh) noreturn =
  let oldTl : ir_dequeue_elt = SELECT(IR_DEQUEUE_HD, deq)
 (* exit if the dequeue is empty *)
  do if Equal(oldTl, IR_DEQUEUE_EMPTY)
        then throw none ()
        else return ()
  let nextTl : ir_dequeue_elt = SELECT(IR_DEQUEUE_ELT_PREV, oldTl)
 (* update the next head element's prev pointer *)
  do if Equal(nextTl, IR_DEQUEUE_EMPTY)
        then return ()
        else let empty : any = (ir_dequeue_elt)IR_DEQUEUE_EMPTY
             do UPDATE(IR_DEQUEUE_ELT_NEXT, nextTl, empty)
             return () 
 (* update the stack head *)
  do UPDATE(IR_DEQUEUE_TL, deq, nextTl)
 (* return the element *)
  let elt : any = SELECT(IR_DEQUEUE_ELT_DATA, oldTl)
  throw some(elt)
;

