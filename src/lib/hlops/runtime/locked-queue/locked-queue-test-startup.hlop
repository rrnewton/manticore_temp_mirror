(*
 * Run me by saying
 *    mc -Cdebug=true -Cscheduler=locked-queue-test triv.pml
 *) 

#include "locked-queue.def"
#include "testing.def"
#include "vproc-queue.def"
#include "cml.def"

define @random-wait (done : ![bool] /exh: exh) : () =
     (* percentage of the time that we do not wait *)
      let pWait : double = 0.90:double
      let one : ml_double = wrap(1.0:double)
      let zero : ml_double = wrap (0.0:double)
      let pW : [double] = @drand (zero, one / exh)
      let p : double = unwrap (pW)
      if F64Lt (p, pWait)
         then return ()
         else @wait (0.1:double, done / exh)
;

define @enq (q : locked_queue, done : ![bool], wait : bool, i : int / exh : exh) : () = 
  fun enq (i : int / exh : exh) : () =
      if I32Eq (i,0)
         then return ()
         else do if wait 
		    then do @random-wait (done/exh)
			 return ()
                    else return ()
              let wi : [int] = wrap (i)
              let wi : any = (any)wi
              do @locked-queue-enqueue (q, wi / exh)
              apply enq (I32Sub(i,1) / exh)
  apply enq (i / exh)
;

define @deq (q : locked_queue, wait : bool, i : int / exh : exh) : bool =
  fun deq (i : int / exh : exh) : bool =
      let jOpt : option = @locked-queue-dequeue (q / exh)
      case jOpt
       of NONE =>  (* if deq needs to wait, then yield, otherwise check to see if the count is zero *)
         let done : bool = I32Eq(i,0)
         if done 
            then return (TRUE)
         else if wait
            then let _ : unit = @yield (host_vproc / exh)
                 apply deq (i / exh)
         else apply deq (i / exh)
	| SOME (wj:[int]) => 
                     let j :int = unwrap(wj)
                     if I32Eq (i,j)
		       then let i : int =  I32Sub (i,1)
                            apply deq (i / exh)
                       else return (FALSE)
      end
  apply deq (i / exh)
;

define @test-q-4 (/ exh : exh) : bool =
  cont error () = return (FALSE)
  let q : locked_queue = @locked-queue-new (/ exh)
  let done :![bool] = alloc (FALSE)
  let done :![bool] = promote(done)

  do @enq (q, done, FALSE, 1 / exh)
  let x : bool = @deq (q, FALSE, 1 / exh)
  do if x then return () else throw error ()

  do @enq (q, done, FALSE, 1 / exh)
  let x : bool = @deq (q, FALSE, 1 / exh)
  do if x then return () else throw error ()

  do @enq (q, done, FALSE, 2 / exh)
  let x : bool = @deq (q, FALSE, 2 / exh)
  do if x then return () else throw error ()

  return (TRUE)  
;

(* test blocking *)
define @test-q-3 ( /exh : exh) : bool =
  let q : locked_queue = @locked-queue-new (/ exh)

  fun doEnq (_ : unit / exh : exh) : unit = 
      let wi : [int] = wrap (999)
      let wi : any = (any)wi
      do @locked-queue-enqueue (q, wi / exh)
      return (UNIT)
  let fgs : fgs = @spawn (doEnq / exh)

  let i : [int] = @locked-queue-blocking-dequeue (q / exh)
  let i : int = unwrap(i)
  let b:  bool = I32Eq(i,999)
  return (b)
;

(* test parallel enqueue and dequeue *)
define @test-q-2 (/ exh : exh) : bool =
  let nElts : int = 50000
  let done :![bool] = alloc (FALSE)
  let done :![bool] = promote(done)
  let q : locked_queue = @locked-queue-new (/ exh)
  fun doEnq (x : unit / exh : exh) : unit = 
      do @enq (q, done, FALSE, nElts / exh)
      return (UNIT)
  let fgs : fgs = @spawn (doEnq / exh)
  @deq (q, TRUE, nElts / exh)
;

(* test fifo ordering *)
define @test-q-1 (/ exh : exh) : bool =
  let nElts : int = 1080
  let done :![bool] = alloc (FALSE)
  let done :![bool] = promote(done)
  let q : locked_queue = @locked-queue-new (/ exh)
  do @enq (q, done, FALSE, nElts /exh)
  @deq (q, FALSE, nElts / exh)
;

define @locked-queue-test-startup ( / exh : exh) : () =
  do @work-stealers-startup (/ exh)
  do_test(test-q-1)
  do_concurrent_test(test-q-2, 20.0:double)
  do_test(test-q-3)
  do_concurrent_test(test-q-4, 20.0:double)
  return ()
;
