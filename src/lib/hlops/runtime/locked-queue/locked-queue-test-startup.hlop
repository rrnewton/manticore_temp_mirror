(*
 * Run me by saying
 *    mc -Cdebug=true -Cscheduler=locked-queue-test triv.pml
 *) 

#include "locked-queue.def"
#include "testing.def"
#include "vproc-queue.def"

define @work-stealers-startup ( / exh : exh) : ();

(* test parallel enqueue and dequeue *)
define @test-q-2 (/ exh : exh) : bool =
  let nElts : int = 2000
  let done :![bool] = alloc (FALSE)
  let q : locked_queue = @locked-queue-new (/ exh)

  fun randomWait (/exh: exh) : () =
     (* percentage of the time that we do not wait *)
      let pWait : double = 0.9:double
      let one : ml_double = wrap(1.0:double)
      let zero : ml_double = wrap (0.0:double)
      let pW : [double] = @drand (zero, one / exh)
      let p : double = unwrap (pW)
      if F64Lt (p, pWait)
         then return ()
         else @wait (0.1:double, done / exh)

  fun enq (i : int / exh : exh) : () = 
      if I32Eq (i,0)
         then return ()
         else do apply randomWait (/exh)
              let wi : [int] = wrap (i)
              let wi : any = (any)wi
              do @locked-queue-enqueue (q, wi / exh)
              apply enq (I32Sub(i,1) / exh)

  fun deq (i : int / exh : exh) : bool =
      let jOpt : option = @locked-queue-dequeue (q / exh)
      case jOpt
       of NONE => 
             let _ : unit = @yield (host_vproc / exh)
             apply deq (i / exh)
	| SOME (wj:[int]) =>               
              let j :int = unwrap(wj)
              if I32Eq (i, 1)
                 then return (TRUE)
              else if I32Eq (i,j)
                 then let i : int =  I32Sub (i,1)
                      apply deq (i / exh)
              else return (FALSE)
      end
  fun doEnq (_ : unit / exh : exh) : unit = 
      do apply enq (nElts / exh)
      return (UNIT)
  let k : fiber = @fiber (doEnq / exh)
  let fgs : fgs = @new-fgs (FALSE, NONE / exh)
  do @enqueue-on-vproc (host_vproc, fgs, k / exh)
  apply deq (nElts / exh)
;

(* test fifo ordering *)
define @test-q-1 (/ exh : exh) : bool =
  let nElts : int = 1080
  let q : locked_queue = @locked-queue-new (/ exh)
  fun enq (i : int / exh : exh) : () = 
      if I32Eq (i,0)
         then return ()
         else let wi : [int] = wrap (i)
              let wi : any = (any)wi
              do @locked-queue-enqueue (q, wi / exh)
              apply enq (I32Sub(i,1) / exh)
  fun deq (i : int / exh : exh) : bool =
      let jOpt : option = @locked-queue-dequeue (q / exh)
      case jOpt
       of NONE => let b : bool = I32Eq(i,0)
                  return (b)
	| SOME (wj:[int]) => 
                     let j :int = unwrap(wj)
                     if I32Eq (i,j)
		       then let i : int =  I32Sub (i,1)
                            apply deq (i / exh)
                       else return (FALSE)
      end
  do apply enq (nElts /exh)
  apply deq ( nElts / exh)
;

define @locked-queue-test-startup ( / exh : exh) : () =
  do @work-stealers-startup (/ exh)
(*  do_test(test-q-1)*)
  do_concurrent_test(test-q-2, 20.0:double
  return ()
;
