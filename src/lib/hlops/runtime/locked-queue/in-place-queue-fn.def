(* in-place-queue-fn.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * In-place queue operations.
 *
 *  To use, apply the define_in_place_queue macro to a unique queue name, a type containing the queue,
 *  and offsets for the head and tail into this type.  For example, we could have a type q with slots
 *  for the head and tail, which implies offsets of 0 and 1 respectively.
 *      type q = ![in_place_queue, in_place_queue]
 *  
 *  The dequeue function is a bit unusual in that you give it return continuations for empty or nonempty
 *  results.
 *)

#include "types.def"
#include "runtime-offsets.def"

#ifndef _IN_PLACE_QUEUE_FN_
#define _IN_PLACE_QUEUE_FN_

#define define_in_place_queue(q_name, q_ty, q_hd_offset, q_tl_offset)                                     \
define @in-place-enqueue-q_name (q : q_ty, qElt : in_place_queue_elt / exh : exh) : () =                  \
  fun qSnoc (qElt : in_place_queue_elt, qt : in_place_queue_elt / exh : exh) : in_place_queue_elt =       \
    do if Equal (qt, IN_PLACE_QUEUE_EMPTY)                                                                \
          then return ()                                                                                  \
          else let qElt : any = (any)qElt      								  \
               do UPDATE(IN_PLACE_QUEUE_ELT_TL, qt, qElt) 						  \
	       return () 			    							  \			
    return (qElt)     											  \
  let qHd : in_place_queue_elt = SELECT(q_hd_offset, q) 						  \
  let qTl : in_place_queue_elt = SELECT(q_tl_offset, q) 						  \
  let qTl : in_place_queue_elt = apply qSnoc (qElt, qTl / exh) 						  \
  do UPDATE(q_tl_offset, q, qTl)       	     	    	  						  \
  if Equal (qHd, IN_PLACE_QUEUE_EMPTY)  								  \
     then (* the queue was empty *) 									  \
          do UPDATE(q_hd_offset, q, qTl) 								  \
          return () 		    									  \
     else return () 											  \
;    	  	 											  \
													  \
define @in-place-dequeue-q_name (q : q_ty, none : cont(), some : cont(any) / exh : exh) : () = 		  \
  let qTl : in_place_queue_elt = SELECT(q_tl_offset, q)        	 	     	   	     		  \
  let qHd : in_place_queue_elt = SELECT(q_hd_offset, q) 						  \
  if Equal (qHd, IN_PLACE_QUEUE_EMPTY) 		     							  \
     then (* the queue is empty *) 									  \
          throw none ()   										  \
     else (* the queue is nonempty, so take an element off the queue head *) 				  \
          let qNext : any = SELECT(IN_PLACE_QUEUE_ELT_TL, qHd) 	     	  				  \
          let qNext : in_place_queue_elt = (in_place_queue_elt)qNext 					  \
          do if Equal (qHd, qTl) 	   								  \
                then (* there is one element on the queue, so clear out the tail *) 			  \
                     let emptyQ : in_place_queue_elt = (in_place_queue_elt)IN_PLACE_QUEUE_EMPTY 	  \
                     do UPDATE(q_tl_offset, q, emptyQ) 							  \
                     return () 		       								  \
                else return () 										  \
          do UPDATE(q_hd_offset, q, qNext) 								  \
          let elt : any = SELECT(IN_PLACE_QUEUE_ELT_HD, qHd) 						  \
          throw some (elt) 										  \
; 	  	     											  \


  
#endif /*!  _IN_PLACE_QUEUE_FN_ */
