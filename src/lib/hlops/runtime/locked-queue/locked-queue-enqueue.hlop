(* locked-queue-enqueue.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Enqueue an element.
 *)

#include "locked-queue.def"
#include "locked-queue-local.def"
#include "assert.def"
#include "vproc-queue.def"

define @locked-queue-enqueue (q : locked_queue, elt : any / exh : exh) : () =

 (* promote elt *before* acquiring the lock *)
  let qElt : in_place_queue_elt = LOCKED_QUEUE_NEW_ELT(elt)
  let qElt : in_place_queue_elt = promote (qElt)  

  let mask : bool = @spin-lock-lq (q / exh)

  cont noneB () = 
       (* "impossible" *)
       let _ : unit = @spin-unlock-lq (q, mask / exh)
       do assert (FALSE)
       return ()
  cont someB (blockedThread : any) =
       let _ : unit = @spin-unlock-lq (q, mask / exh)
       let blockedThread : locked_queue_blocked_thread = (locked_queue_blocked_thread)blockedThread
       let blockedK : cont(any) = SELECT(LOCKED_QUEUE_BLOCKED_THREAD_CONT, blockedThread)
       let blockedFgs : fgs = SELECT(LOCKED_QUEUE_BLOCKED_THREAD_FGS, blockedThread)
       let vp : vproc = SELECT(LOCKED_QUEUE_BLOCKED_THREAD_VPROC, blockedThread)
       cont unblockK (x : unit) =
            throw blockedK (elt)
       let unblockK : fiber = (fiber)unblockK
       @enqueue-on-vproc (vp, blockedFgs, unblockK / exh)

 (* check for blocked threads first *)
  let bqHd : in_place_queue_elt = SELECT(LOCKED_QUEUE_BLOCKED_HD, q)
  do if Equal (bqHd, NIL)
        then (* nothing is blocked; enqueue the element *)
             @in-place-enq-tl-lq (q, qElt / exh)
        else (* unblock the thread and pass it the element *)
             do @in-place-deq-hd-bq (q, noneB, someB / exh)
             assert(FALSE)

  let _ : unit = @spin-unlock-lq (q, mask / exh)

  return ()
;
