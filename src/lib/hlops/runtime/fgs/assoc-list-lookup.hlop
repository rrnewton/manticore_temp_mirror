(* assoc-list-lookup.hlop
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Lookup a tag in the association list.  If the tag exists, return its associated value,
 * but otherwise initialize the tag with a fresh associated value and return it.
 *)

#include "fgs.def"
#include "../synch/spin-lock-fn.hlop"
define_spin_lock(fgs, fgs, FGS_LOCK_OFFSET)

(* assoc-list-add: initialize atag in the assocation list if necessary, and return the assoicated value.  
 *   - atag: tag to add
 *   - init: function that initializes the item if none exists
 *   - fgs: fiber group storage that contains the assoication list
 *)
define @assoc-list-add (atag : assoc_tag, init : fun(unit / exh -> any), fgs : fgs / exh : exh) : any =
  let mask : bool = @spin-lock-fgs (fgs / exh)
  let alistSrc : assoc_list = SELECT(FGS_ALIST_OFFSET, fgs)
 (* initialize the element if the tag is not found, and return the element otherwise *)
  fun lookup (alist : assoc_list / exh : exh) : any =
      case alist
       of ANIL => 
         (* did not find the tag, so initialize an element.
	  * NOTE: the instructions below perform allocations, which is bad to do while holding a lock because they might
	  * trigger a minor collection.  In this case we're probably safe because initializations occur infrequently.
	  *)
	  let elt : any = apply init (UNIT / exh)
	  let alistNew : assoc_list = ACONS (atag, elt, alistSrc)
	  let alistNew : assoc_list = promote (alistNew)
	  do UPDATE(FGS_ALIST_OFFSET, fgs, alistNew)
	  let _ : unit = @spin-unlock-fgs (fgs, mask / exh)
	  return (elt)
	| ACONS (atag' : assoc_tag, elt : any, alist : assoc_list) => 
	  if Equal (atag, atag')
	     then (* found the tag, so return the associated value. *)
		   let _ : unit = @spin-unlock-fgs (fgs, mask / exh)
		   return (elt)
	     else apply lookup (alist / exh)
      end
  apply lookup (alistSrc / exh)
;

(* assoc-list-lookup
 * - atag: tag to lookup
 * - init: function that initializes the item if none exists
 * - fgs: fiber group storage that contains the assoication list
 *)
define @assoc-list-lookup (atag : assoc_tag, init : fun(unit / exh -> any), fgs : fgs / exh : exh) : any =
  let eltOpt : option = @assoc-list-query(atag, fgs / exh)
  case eltOpt
   of NONE =>
     (* initialize a fresh element *)                   
      let elt : any = @assoc-list-add(atag, init, fgs / exh)
      return (elt)
    | SOME (elt : any) => return(elt)
  end
;
