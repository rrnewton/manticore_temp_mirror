(* cancel-cell.hlop
 * 
 * COPYRIGHT (c) 2008 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Allocate a cancel cell.
 *)

#include "types.def"
#include "tags.def"
#include "debugging.def"
#include "fiber-cancellation.def"

define inline @cancel-cell (/ exh : exh) : cancel_cell =

  fun optJoin (opt : option / exh : exh) : option =
      case opt
       of NONE => return(NONE)
	| SOME (opt : option) => return(opt)
      end

  let fgs : fgs = @get-fgs (host_vproc / exh)
  let parent : option = @assoc-list-query(tag(cancelCell), fgs / exh)
  let parent : option = apply optJoin(parent / exh)
  
  let cancelCell : cancel_cell = alloc(FALSE, NIL, parent)
  let cancelCell : cancel_cell = promote(cancelCell)

 (* add this cancel cell to the children of the running fiber *)
  do case parent
      of NONE => return()
       | SOME (c : cancel_cell) => 
         let children : list = SELECT(CHILDREN_OFF, c)
         let newChildren : list = CONS(cancelCell, children)
         let newChildren : list = promote(newChildren)
	 do UPDATE(CHILDREN_OFF, c, newChildren)
         return ()
     end

  (* if some other fiber has canceled parent, that fiber may or may not have seen the
   * update to the parent's child list. therefore, we could have a situation where
   * cancelCell gets to run even when parent has been canceled.  we fix this problem
   * by polling below.
   *)

  let _ : unit = @yield(host_vproc /exh)

  return(cancelCell)
;
