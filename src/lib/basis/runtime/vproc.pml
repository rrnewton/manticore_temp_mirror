(* vproc.pml
 *
 * COPYRIGHT (c) 2009 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Virtual processors.
 *)

structure VProc (* :
  sig

    _prim(

    (** unique ids **)

    (* unique id of a vproc *)
      define @vproc-id (vp : vproc) : int;
    (* find the vproc with a given unique id *)
      define @vproc-by-id (id : int) : vproc =
    (* total number of vprocs *)
      define @num-vprocs (/ exh : exh) : int;

    (** vproc allocation and iterators **)

    (* returns the list of all vprocs *)
      define @all-vprocs () : List.list;
    (* returns the list of all vprocs, but not the host vproc *)
      define @other-vprocs (/ exh : exh) : List.list;
    (* apply f to each vproc *)
      define @for-each-vproc(f : fun(vproc / exh ->) / exh : exh) : ();
    (* apply f to each vproc except the host vproc *)
      define @for-other-vprocs(f : fun(vproc / exh ->) / exh : exh) : ();

    (** initialization and idling **)

    (* bootstrap the default scheduler *)
      define @boot-default-scheduler (act : PT.sched_act / exh : exh) : ();
    (* wait for work to arrive at the vproc *)
      define @wait-from-atomic (vp : vproc) : ();

    )
    
  end *) = struct

    structure PT = PrimTypes

    _primcode (

    (* hooks into the C runtime system (parallel-rt/vproc/vproc.c) *)
      extern void* GetNthVProc (int);
      extern int GetNumVProcs ();
      extern void *SleepCont (void *) __attribute__((alloc));
      extern void *ListVProcs (void *) __attribute__((alloc));

    (* returns the total number of vprocs *)
      define inline @num-vprocs () : int =
	  let n : int = ccall GetNumVProcs()
	  return (n)
	;

    (* returns the unique id of the given vproc *)
      define inline @vproc-id (vp : vproc) : int =
	  let id : int = vpload(VPROC_ID, vp)
	  return (id)
	;

    (* find the vproc with a given unique id *)
      define @vproc-by-id (id : int) : vproc =
#ifndef NDEBUG
	  let max : int = @num-vprocs()
	  do assert(I32Lt(id, max))
	  do assert(I32Gte(id, 0))
#endif
	  let vp : vproc = ccall GetNthVProc(id)
	  return (vp)
	;

    (** vproc allocation and iterators  **)

    (* returns the list of all vprocs *)
      define @all-vprocs () : List.list =
	  let vps : List.list = ccall ListVProcs(host_vproc)
	  return(vps)
	;

    (* returns the list of all vprocs, but not the host vproc *)
      define @other-vprocs (/ exh : exh) : List.list =
	  let self : vproc = host_vproc
	  fun lp (vps : List.list, others : List.list) : List.list =
	      case vps
	       of nil => return(others)
		| List.CONS(vp : [vproc], vps : List.list) =>
		    if Equal(#0(vp), self)
		      then apply lp(vps, others)
		      else apply lp(vps, List.CONS(vp, others))
	      end
	  let vps : List.list = ccall ListVProcs(self)
	  apply lp(vps, nil)
	;

    (* apply f to each vproc *)
      define @for-each-vproc(f : fun(vproc / exh ->) / exh : exh) : () =
	  fun lp (vps : List.list) : () =
	      case vps
	       of nil => return()
		| List.CONS(vp : [vproc], vps : List.list) =>
		  do apply f(#0(vp) / exh)
		  apply lp(vps)
	      end
	  let vps : List.list = ccall ListVProcs(host_vproc)
	  apply lp(vps)
	;

    (* apply f to each vproc except the host vproc *)
      define @for-other-vprocs (f : fun(vproc / exh ->) / exh : exh) : () =
	  let self : vproc = host_vproc
	  fun g (vp : vproc / exh : exh) : () =
		if NotEqual(vp, self) then apply f(vp / exh)
		else return()
	  @for-each-vproc(g / exh)
	;

    (** initialization and idling **)

    (* the trampoline is a continuation that receives asynchronous signals generated by the C runtime, and
     * passes those signals to the scheduler action at the top of the scheduler-action stack.
     *
     * IMPORTANT: this operation must precede any other scheduling operations, and signals must be masked before
     * this operation completes.
     *)
      define @set-trampoline ( / exh : exh) : () =
	(* the trampoline passes signals from the C runtime to the current scheduler. there are two possibilities:
	 *  1. the vproc was awoken from an idle state
	 *  2. a timer interrupt arrived
	 *)
	  cont trampoline (k : PT.fiber) = 
	    if Equal(k, M_NIL)
	      then  (* case 1 *)
		SchedulerAction.@forward(PT.STOP)
	      else (* case 2 *)
		SchedulerAction.@forward(PT.PREEMPT(k))
	  let trampoline : cont(PT.fiber) = promote(trampoline)
	(* set the trampoline on a given vproc *)
	  fun setTrampoline (vp : vproc / exh : exh) : () =
	      let currentTrampoline : cont(PT.fiber) = vpload(VP_SCHED_CONT, vp)
	      do assert(Equal(currentTrampoline, nil))
	      do vpstore(VP_SCHED_CONT, vp, trampoline)
	      return()
	  @for-each-vproc(setTrampoline / exh)
	;

    (* push a scheduler action on a remote vproc's stack.
     * NOTE: because this operation is not "thread safe", we should only use it during runtime 
     * initialization.
     *)
      define @push-remote-act (vp : vproc, act : PT.sched_act / exh : exh) : () =
	  do assert(NotEqual(act, nil))
	  let stk : [PT.sched_act, any] = vpload (VP_ACTION_STK, vp)
	  let item : [PT.sched_act, any] = alloc (act, (any)stk)
	  let item : [PT.sched_act, any] = promote (item)
	  do vpstore (VP_ACTION_STK, vp, item)
(* FIXME: insert a write barrier here *)
	  return()
	;

    (* push a copy of the top-level scheduler on each vproc (except the host)  *)
      define @seed-remote-action-stacks (mkAct : fun (vproc / exh -> PT.sched_act) / exh : exh) : () =
	  fun f (vp : vproc / exh : exh) : () =
	      let act : PT.sched_act = apply mkAct (vp / exh)
	      @push-remote-act(vp, act / exh)
	  @for-other-vprocs(f / exh)
	;

    (* bootstrap the default scheduler *)
      define @boot-default-scheduler (mkAct : fun (vproc / exh -> PT.sched_act) / exh : exh) : () =
	  let self : vproc = SchedulerAction.@atomic-begin()
	  let fls : FLS.fls = FLS.@get()
	  do @set-trampoline (/ exh)
	  do @seed-remote-action-stacks(mkAct / exh)
	  cont startLeadK (_ : PT.unit) = return()
	  let act : PT.sched_act = apply mkAct (self / exh)
	  SchedulerAction.@run(self, act, startLeadK)
	;

#define BUSY_WAIT

#ifdef BUSY_WAIT
    (* wait for work to arrive at the vproc *)
      define @wait-from-atomic (vp : vproc) : () =
          return()
        ;
#endif /*! BUSY_WAIT */

#ifdef SLEEP_IN_C_RUNTIME
    (* wait for work to arrive at the vproc *)
      define @wait-from-atomic (vp : vproc) : () =
	  fun sleep () : () =
	      cont wakeupK (x : unit) = return ()
	    (* the C runtime expects the resumption continuation to be in vp->wakeupCont *)
	      do vpstore(VP_WAKEUP_CONT, vp, wakeupK)
	    (* SleepCont resides in parallel-rt/vproc.c *)
	      let sleepK : PT.fiber = ccall SleepCont (vp)
	      throw sleepK(UNIT)
	  do apply sleep()
	  return()
	;
#endif /*! SLEEP_IN_C_RUNTIME */

#ifdef NANOSLEEP
      extern void Nanosleep(long, long);
    (* wait for work to arrive at the vproc *)
      define @wait-from-atomic (vp : vproc) : () =
          do ccall Nanosleep(0, 1000)
          return()
        ;
#endif /*! NANOSLEEP */

    (* mask signals before running any scheduling code *)
      define @mask-signals (x : unit / exh : exh) : unit =
	  let vp : vproc = SchedulerAction.@atomic-begin()
	  return (UNIT)
	;

    (* initialize fls *)
      define @init-fls (x : unit / exh : exh) : unit = 
	  let fls : FLS.fls = FLS.@new (UNIT / exh)
	  do FLS.@set(fls)
	  return (UNIT)
	;

    )

  (* signals must be masked before initializing the rest of the runtime *)
    val maskSignals : unit -> unit = _prim(@mask-signals)
    val () = maskSignals()

  (* create fls for the root thread *)
    val initFLS : unit -> unit = _prim(@init-fls)
    val () = initFLS() 

  end
