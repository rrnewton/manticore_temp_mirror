#!/bin/bash

# To generate timing results, run this script in the benchmark directory with the following command-line arguments.
# Generate timing results for a benchmark.
#   INPUT: 
#           -e prog_name               name of the program you wish to benchmark.  The pml file be located at benchmarks/prog_name/prog_name.pml
#           -q seq_prog_name           optional name of the sequential program for benchmarking.  The pml file should be located at prog_name/seq_prog_name.pml.
#           -s size                    integer size for testing.
#           -l seq_sz                  integer size for switching to the sequential base case.
#           -p num_procs               number of processors.  Using -p 0 causes sequential compilation.
#
# To make a new benchmark for program prog, 
#    1. Create the directory benchmark/prog.
#    2. Places prog.pml in benchmark/prog.
#    3. Modify prog.pml so that it takes two integer arguments from stdin, the sequential base case size
#       and the input size and have it report the time to evaluate.

GOTO_SEQ_SIZES=""

usage="usage: benchmark.bsh -e prog_name -q sequential_prog_name -s size ... -p num_procs ... -l seq_sz ..."
SEQ_PROG_NAME=""
while getopts ":s:p:e:q:l:" options; do
  case $options in
    s ) SIZES="$SIZES $OPTARG";;
    p ) PROCS="$PROCS $OPTARG";;
    e ) PROG_NAME="$OPTARG";;
    l ) GOTO_SEQ_SIZES="$GOTO_SEQ_SIZES $OPTARG";;
    q ) SEQ_PROG_NAME="$OPTARG";;
    h ) echo $usage;;
    \? ) echo $usage
         exit 1;;
    * ) echo $usage
          exit 1;;

  esac
done

if [ -z "$PROCS" ]; then
    echo "Enter at least one choice for the number of processors"
    exit 1
fi

PROG_EXE=$PROG_NAME-run

# compiler flags
MC="sml @SMLcmdname=mc @SMLload=../../mc"
MCFLAGS="-Cclos.convert-style=flatWithCFA -Ctranslate-pvals=true"
SEQFLAGS="$MCFLAGS -Csequential=true"

DATE=$( date +"%F-%H-%M-%S" )
LOG_FILE_NAME=$PROG_NAME-$DATE.times
echo "Logging performance results to $LOG_FILE_NAME"

# compile the sequential version
if [ -z "$SEQ_PROG_NAME" ] ; then
    SEQ_PROG_NAME=$PROG_NAME
fi
SEQ_PROG_EXE=$PROG_NAME-seq
m4 $PROG_NAME/$SEQ_PROG_NAME.pml > $SEQ_PROG_NAME.pml
echo "Compiling sequential program: $MC $SEQFLAGS $SEQ_PROG_NAME.pml"
$MC $SEQFLAGS $SEQ_PROG_NAME.pml 2> /dev/null
mv a.out $SEQ_PROG_EXE

# metadata
ARCH=$( uname -m )
OS=$( uname -s )
MACHINE=$( uname -n )
SVN_REVISION=$( svn info | grep Revision )
echo -e "#ARCH:\t$ARCH OS:\t$OS MACHINE:\t$MACHINE" >> $LOG_FILE_NAME
echo -e "#MCFLAGS\t$MCFLAGS" >> $LOG_FILE_NAME
echo -e "#SVN $SVN_REVISION" >> $LOG_FILE_NAME
echo -e "#nProcs\t\tsize\t\tmaxLeafSize\ttime(s)" >> $LOG_FILE_NAME 

PARFLAGS="$MCFLAGS"
#run the macro expander on the source program
m4 $PROG_NAME/$PROG_NAME.pml > $PROG_NAME.pml
#compile the parallel version
echo "Compiling parallel program: $MC $PARFLAGS $PROG_NAME.pml"
$MC $PARFLAGS $PROG_NAME.pml 2> /dev/null
mv a.out $PROG_EXE

for seq_sz in $GOTO_SEQ_SIZES
do
    for p in $PROCS
    do   
        for s in $SIZES
	do
	    echo "evaluating $PROG_NAME for $p processor[s] at image size $s and sequential size $seq_sz"
	    echo -n -e "$p\t\t$s\t\t$seq_sz\t\t" >> $LOG_FILE_NAME
	    if [ "$p" -eq "0" ] ; then       
		echo "$seq_sz $s." | ./$SEQ_PROG_EXE >> $LOG_FILE_NAME
	    else
		echo "$seq_sz $s." | ./$PROG_EXE -p $p >> $LOG_FILE_NAME
	    fi
	done
    done
done

# clean up
rm -f *.ppm *.s $PROG_EXE $SEQ_PROG_EXE $SEQ_PROG_NAME.pml $PROG_NAME.pml
