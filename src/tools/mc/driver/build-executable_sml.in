(* build-executable.sml
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * @configure_input@
 *
 * A wrapper for the commands needed to assemble and link the output
 * of the Manticore compiler.
 *)

structure BuildExecutable : sig

    val build : {
	    verbose : bool,	(* if true, print shell commands to stdout *)
	    asmFile : string,	(* the assembly file generated by the compiler *)
	    outFile : string	(* the name of the executable image. *)
	  } -> OS.Process.status

  end = struct
  
    structure PrintTbl = PrintTable
	structure PrintTblDbg = PrintTableDebug

    val cat = String.concatWith " "

    fun ++ ("", l) = l
      | ++ (opt, l) = opt::l

    infixr ++

    val isCrossCompiler = (@CROSS_COMPILING@ = 1)

    val ccCmd =  "@CC@"

    val cFlags = cat ("@CFLAGS@" ++ "@CFLAG_M64@" ++ [])

    fun ldFlags libName = let
	  val libDirs = List.filter (fn path => OS.FileSys.access (path, [])) [
		  "@prefix@/lib",
		  "@MANTICORE_LIBDIR@",
		  "@MANTICORE_SRCDIR@/lib/parallel-rt/build/" ^ libName
		]
	  val libDirs = List.map (fn path => "-L" ^ path) libDirs
	  val rtLib = "-l" ^ libName
	  in
	    cat (libDirs @ (rtLib ++ "@LDFLAGS@" ++ "@LIBS@" ++ "-lpthread" ++ []))
	  end

    fun systemWithTiming (cmd, mustPrint) = let
        val verbose = mustPrint orelse (Controls.get BasicControl.verbose > 0)
        val inclusiveStart = Time.now()
        val _ = (if verbose
	         then TextIO.print(cmd ^ "\n")
	         else ())
        val result = OS.Process.system cmd;
    in
        if verbose
        then TextIO.print(concat ["Compile finished in: ",
                                  (Time.toString (Time.- (Time.now(), inclusiveStart))),
                                  "\n"])
        else ();
        result
    end

    fun cmd asmFile = let
	  val gcStats = Controls.get BasicControl.gcStats
	  val logging = Controls.get BasicControl.logging
	  val debug = Controls.get BasicControl.debug
	  val perf = Controls.get BasicControl.perf
	  val (cFlags, libName) = (case (gcStats, logging, debug, perf)
		 of (true, false, false, false) => (cFlags, "mcrt-stats")
		  | (_, false, false, false) => (cFlags, "mcrt")
		  | (_, true, false, false) => (cFlags, "mcrt-log")
		  | (_, false, true, false) => ("-g "^cFlags^" -O0", "mcrt-debug")
		  | (_, true, true, false) => ("-g "^cFlags^" -O0", "mcrt-log-debug")
		  | (_, _, _, true) => (cFlags, "mcrt-perf")
		(* end case *))
	  val filename = OS.FileSys.tmpName()
          val filenamec = concat[filename,".c"]
          val filenameo = concat[filename,".o"]  
	  val gccfilename = concat ["gcc @CFLAGS@ -O1 -fregmove @LIBS@ @CFLAG_M64@ -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/ -I @MANTICORE_SRCDIR@/include -o ",filenameo," -std=c99 -c ",filenamec]
	  val _ = PrintTbl.print filenamec
	  val _ = systemWithTiming (gccfilename, false)
	  
	  fun tableFiles () =
              if (debug) 
              then let
		      val filenamedebug = OS.FileSys.tmpName()
		      val filenamedebugc = concat[filenamedebug,".c"]
		      val filenamedebugo = concat[filenamedebug,".o"]  
		      val gccfilenamedebug = concat ["gcc @CFLAGS@ -O0 @LIBS@ @CFLAG_M64@ -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/ -I @MANTICORE_SRCDIR@/include -o ",filenamedebugo," -std=c99 -c ",filenamedebugc]
		      val _ = PrintTblDbg.print filenamedebugc
		      val _ = systemWithTiming (gccfilenamedebug, false)
	          in
                      (concat[filenameo," ",filenamedebugo],
                       [filenamec, filenameo, filenamedebugc, filenamedebugo])
                  end
              else 
                  (filenameo, [filenamec, filenameo])
                  
          val (files, temps) = tableFiles ()
    in
	(cat [ccCmd, cFlags, asmFile,files, ldFlags libName], temps)
    end

    fun build {verbose, asmFile, outFile} = if isCrossCompiler
	  then (
	    TextIO.output(TextIO.stdErr, "cross compiler cannot produce executables\n");
	    OS.Process.failure)
	  else let
                  val (cmdline, temps) = cmd asmFile
	          val cmd' = cat[cmdline, " -o ", outFile]
                  val result = systemWithTiming (cmd', verbose);
	          val debug = Controls.get BasicControl.debug
	      in
                  if not debug
                  then (List.app OS.FileSys.remove temps)
                  else ();
                  result
	      end

  end
