(* build-executable.sml
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * @configure_input@
 *
 * A wrapper for the commands needed to assemble and link the output
 * of the Manticore compiler.
 *)

structure BuildExecutable : sig

    val build : {
	    verbose : bool,	(* if true, print shell commands to stdout *)
	    asmFile : string,	(* the assembly file generated by the compiler *)
	    outFile : string	(* the name of the executable image. *)
	  } -> OS.Process.status

  end = struct

    val cat = String.concatWith " "

    val isCrossCompiler = (@CROSS_COMPILING@ = 1)
    val ccCmd =  "@CC@"
    val cFlags = "@CFLAGS@"
    fun ldFlags libName = cat (
          (List.map (fn path => "-L" ^ path) (
             List.filter (fn path => OS.FileSys.access (path, [])) [
	       "@prefix@/lib",
	       "@MANTICORE_LIBDIR@",
	       "@MANTICORE_SRCDIR@/lib/parallel-rt/build/" ^ libName
             ])
          ) @ [
	    "@LDFLAGS@",
	    "-l" ^ libName,
	    "-lpthread"
	  ])

    fun cmd asmFile = let
	  val logging = if Controls.get BasicControl.logging then "-log" else ""
	  val (cFlags, debug) = if Controls.get BasicControl.debug
		then ("-g" :: cFlags, "-debug")
		else (cFlags, "")
	  val libName = concat ["mcrt", logging, debug]
	  in
	    cat [ccCmd, cFlags, asmFile, ldFlags libName]
	  end

    fun build {verbose, asmFile, outFile} = if isCrossCompiler
	  then (
	    TextIO.output(TextIO.stdErr, "cross compiler cannot produce executables\n");
	    OS.Process.failure)
	  else let
	    val cmd' = cat[cmd asmFile, " -o ", outFile]
	    in
	      if verbose
		then TextIO.print(cmd' ^ "\n")
		else ();
	      OS.Process.system cmd'
	    end

  end
