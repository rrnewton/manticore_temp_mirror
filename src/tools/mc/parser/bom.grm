(* hlop-def.grm
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * TODO:
 *	add datatype definitions
 *	rewrite rules
 *)

%name HLOpDef;

%tokens
	: KW_addr	("addr")
	| KW_alloc	("alloc")
(*	| KW_and	("and")			*)
	| KW_any	("any")
	| KW_apply	("apply")
	| KW___attribute__ ("__attribute__")
	| KW_byte	("byte")
(*	| KW_case	("case")		*)
	| KW_ccall	("ccall")
	| KW_cont	("cont")
(*	| KW_datatype	("datatype")		*)
	| KW_define	("define")
	| KW_do		("do")   
	| KW_double	("double")
(*	| KW_else	("else")		*)
(*	| KW_end	("end")			*)
	| KW_enum	("enum")
	| KW_extern	("extern")
	| KW_float	("float")
(*	| KW_fun	("fun")			*)
	| KW_host_vproc ("host_vproc")
(*	| KW_if		("if")			*)
	| KW_inline	("inline")
	| KW_int	("int")
(*	| KW_let	("let")			*)
	| KW_long	("long")
	| KW_module	("module")
	| KW_noreturn	("noreturn")
(*	| KW_of		("of")			*)
	| KW_promote	("promote")
	| KW_pure	("pure")
        | KW_return	("return")
	| KW_short	("short")
	| KW_tag        ("tag")
(*	| KW_then	("then")		*)
	| KW_throw	("throw")
	| KW_typedef	("typedef")
	| KW_unwrap	("unwrap")
        | KW_use_rw     ("use_rw")
	| KW_vec128	("vec128")
	| KW_void	("void")
	| KW_vproc	("vproc")
	| KW_vpload	("vpload")
	| KW_vpstore	("vpstore")
	| KW_wrap	("wrap")
(*	| LP		("(")			*)
(*	| RP		(")")			*)
(*	| LB		("[")			*)
(*	| RB		("]")			*)
	| HASH		("#")
(*	| STAR		("*")			*)
(*	| COMMA		(",")			*)
(*	| EQ		("=")			*)
(*	| COLON		(":")			*)
(*	| SLASH		("/")			*)
(*	| SEMI		(";")			*)
(*	| BAR		("|")			*)
(*	| WILD		("_")			*)
(*	| BANG		("!")			*)
(*	| AMP		("&")			*)
	| DS		("$")
	| ASSIGN	(":=")
(*	| DARROW	("=>")			*)
(*	| ARROW		("->")			*)
(*	| ID of Atom.atom			*)
	| HLOP of Atom.atom
(*	| POSINT of IntInf.int		(* positive integer *) *)
(*	| NEGINT of IntInf.int		(* negative integer *) *)
(*	| FLOAT of FloatLit.float		*)
(*	| STRING of string			*)
	| ML_STRING of string
	;

%defs(
    structure BPT = BOMParseTree
    structure CF = CFunctions

    fun flatten NONE = []
      | flatten (SOME(x, xs)) = x::xs

  (* default types for literals *)
    val dfltIntTy = BPT.T_Raw(BPT.T_Int)
    val dfltFloatTy = BPT.T_Raw(BPT.T_Float)
    val dfltStringTy = BPT.T_Any (* FIXME *)
);


BOMDecls
	: Definition+
		=> (Definition)
	;


Definition
	: "extern" CRetTy ID "(" (CArgTy ("," CArgTy)* )? ")" Attrs ";"
		=> (BPT.D_Extern(CF.CFun{
			var = ID,
			name = Atom.toString ID,
			retTy = CRetTy,
			argTys = flatten SR,
			varArg = false,
			attrs = Attrs
		      }))
	| "typedef" ID "=" BOMType ";"
		=> (BPT.D_TypeDef(ID, BOMType))
	| "define" optInline HLOP FunParams ReturnTy ("=" BOMExp)? ";"
		=> (let val (p1, p2) = FunParams in
		      BPT.D_Define(optInline, HLOP, p1, p2, ReturnTy, SR)
		    end)
	;

CRetTy
	: "void"	=> (CF.VoidTy)
	| CArgTy	=> (CArgTy)
	;

CArgTy
	: RawType	=> (CF.BaseTy RawType)
	| "void" "*"	=> (CF.PointerTy)
	;

Attrs
	: (* empty *)	=> ([])
	| "__attribute__" "(" "(" Attr ("," Attr)* ")" ")"
		=> (Attr :: SR)
	;

Attr
	: "pure"	=> (CF.A_pure)
	| "alloc"	=> (CF.A_alloc)
	| "noreturn"	=> (CF.A_noreturn)
	;

ReturnTy
	: "noreturn"		=> (NONE)
	| ":" BOMType		=> (SOME[BOMType])
	| ":" "(" TypeList ")"	=> (SOME TypeList)
	;

optInline
	: (* empty *)	=> (false)
	| "inline"	=> (true)
	;

FunParams
	: "(" Params ("/" Params)? ")"		=> (Params, case SR of SOME l => l | _ => [])
	;

Params
	: (VarPat ("," VarPat)* )?		=> (flatten SR)
	;

BOMType
	: "addr" "(" BOMType ")"		=> (BPT.T_Addr(BOMType))
	| "any"					=> (BPT.T_Any)
	| "enum" "(" POSINT ")"			=> (BPT.T_Enum(Word.fromLargeInt POSINT))
	| RawType				=> (BPT.T_Raw RawType)
	| "!" "[" BOMType ("," BOMType)* "]"	=> (BPT.T_Tuple(true, BOMType :: SR))
	| "[" BOMType ("," BOMType)* "]"	=> (BPT.T_Tuple(false, BOMType :: SR))
	| "fun" "(" TypeList "/" TypeList "->" TypeList ")"
						=> (BPT.T_Fun(TypeList1, TypeList2, TypeList3))
	| "cont" "(" TypeList ")"		=> (BPT.T_Cont TypeList)
	| "vproc"				=> (BPT.T_VProc)
	| ID					=> (BPT.T_TyCon ID)
	;

TypeList
	: (BOMType ("," BOMType)* )?  => (flatten SR)
	;

RawType
	: "byte"	=> (BPT.T_Byte)
	| "short"	=> (BPT.T_Short)
	| "int"		=> (BPT.T_Int)
	| "long"	=> (BPT.T_Long)
	| "float"	=> (BPT.T_Float)
	| "double"	=> (BPT.T_Double)
	| "vec128"	=> (BPT.T_Vec128)
	;

BOMExp
	: "let" LHS "=" RHS BOMExp
		=> (BPT.E_Let(LHS, RHS, BOMExp))
	| "do" RHS BOMExp
		=> (BPT.E_Let([], RHS, BOMExp))
	| "fun" BOMLambda ("and" BOMLambda)* BOMExp
		=> (BPT.E_Fun(BOMLambda::SR, BOMExp))
	| "cont" CLambda BOMExp
		=> (BPT.E_Cont(CLambda, BOMExp))
	| "if" SimpleExp "then" BOMExp "else" BOMExp
		=> (BPT.E_If(SimpleExp, BOMExp1, BOMExp2))
        | "case" SimpleExp "of" Rules ("|" Default)? "end"
		=> (BPT.E_Case(SimpleExp, Rules, SR))
	| "apply" ID "(" Args ("/" Args)? ")"
		=> (BPT.E_Apply(ID, Args, Option.getOpt(SR, [])))
	| "throw" ID "(" Args ")"
		=> (BPT.E_Throw(ID, Args))
	| "return" "(" Args ")"
		=> (BPT.E_Return Args)
	| HLOP "(" Args ("/" Args)? ")"
		=> (BPT.E_HLOpApply(HLOP, Args, Option.getOpt(SR, [])))
	;

BOMLambda
	: ID FunParams ":" FunReturnTy "=" BOMExp
		=> (let val (p1, p2) = FunParams in (ID, p1, p2, FunReturnTy, BOMExp) end)
	;

FunReturnTy
	: BOMType			=> ([BOMType])
	| "(" TypeList ")"		=> (TypeList)
	;

CLambda
	: ID "(" Params ")" "=" BOMExp	=> (ID, Params, [], [], BOMExp)
	;

LHS
	: VarPat			=> ([VarPat])
	| "(" Params ")"		=> (Params)
	;

RHS
	: BOMExp			=> (BPT.RHS_Exp BOMExp)
	| NonSelectExp			=> (BPT.RHS_SimpleExp NonSelectExp)
	| "#" POSINT "(" SimpleExp ")" (":=" SimpleExp)?
		=> (case SR
		     of SOME e => BPT.RHS_Update(Int.fromLarge POSINT, SimpleExp, e)
		      | NONE => BPT.RHS_SimpleExp(BPT.SE_Select(Int.fromLarge POSINT, SimpleExp))
		    (* end case *))
	| "promote" "(" SimpleExp ")"	=> (BPT.RHS_Promote SimpleExp)
	| "ccall" ID "(" Args ")"	=> (BPT.RHS_CCall(ID, Args))
	| "vpstore" "(" POSINT "," SimpleExp "," SimpleExp ")"
					=> (BPT.RHS_VPStore(POSINT, SimpleExp1, SimpleExp2))
	;

NonSelectExp
	: ID				=> (BPT.SE_Var ID)
	| "alloc" "(" Args ")"		=> (BPT.SE_Alloc Args)
	| "wrap" "(" SimpleExp ")"	=> (BPT.SE_Wrap SimpleExp)
	| "&" POSINT "(" SimpleExp ")"	=> (BPT.SE_AddrOf(Int.fromLarge POSINT, SimpleExp))
	| "unwrap" "(" SimpleExp ")"	=> (BPT.SE_Unwrap SimpleExp)
	| ID "(" Args ")"		=> (BPT.SE_Prim(ID, Args))
	| "(" BOMType ")" SimpleExp	=> (BPT.SE_Cast(BOMType, SimpleExp))
	| Literal			=> (BPT.SE_Const(Literal))
	| ML_STRING			=> (BPT.SE_MLString(ML_STRING))
	| "host_vproc"			=> (BPT.SE_HostVProc)
	| "vpload" "(" POSINT "," SimpleExp ")"
					=> (BPT.SE_VPLoad(POSINT, SimpleExp))
	;

SimpleExp
	: NonSelectExp			=> (NonSelectExp)
	| "#" POSINT "(" SimpleExp ")"	=> (BPT.SE_Select(Int.fromLarge POSINT, SimpleExp))
	;

Args
	: (SimpleExp ("," SimpleExp)* )?	=> (flatten SR)
	;

Rules
	: Rule ("|" Rule)*		=> (Rule :: SR)
	;

Rule
	: ID "(" VarPat ("," VarPat)* ")" "=>" BOMExp
					=> (BPT.P_DCon(ID, VarPat::SR), BOMExp)
	| Literal "=>" BOMExp		=> (BPT.P_Const Literal, BOMExp)
	;

Default
	: VarPat "=>" BOMExp		=> (VarPat, BOMExp)
	;

VarPat
	: "_" (":" BOMType)?		=> (BPT.P_Wild SR)
	| ID ":" BOMType		=> (BPT.P_Var(ID, BOMType))
	;

Literal
	: "enum" "(" POSINT ")" (":" BOMType)?
		=> (let
		    val w = Word.fromLargeInt POSINT
		    in
		      case SR
		       of NONE => (Literal.Enum w, BPT.T_Enum w)
			| SOME ty => (Literal.Enum w, ty)
		      (* end case *)
		    end)
        | "tag" "(" ID ")"
                 => (Literal.Tag (Atom.toString ID), BPT.T_Any)
	| "$" POSINT
		=> (Literal.StateVal(Word.fromLargeInt POSINT), BPT.T_Any)
	| Int (":" IntTy)?
		=> (case SR
		   of NONE => (Literal.Int Int, dfltIntTy)
		    | SOME ty => (Literal.Int Int, ty)
		  (* end case *))
	| FLOAT (":" FloatTy)?
		=> (case SR
		   of NONE => (Literal.Float FLOAT, dfltFloatTy)
		    | SOME ty => (Literal.Float FLOAT, ty)
		  (* end case *))
	| STRING
		=> (Literal.String STRING, dfltStringTy)
	;

IntTy	: "byte"	=> (BPT.T_Raw BPT.T_Byte)
	| "short"	=> (BPT.T_Raw BPT.T_Short)
	| "int"		=> (BPT.T_Raw BPT.T_Int)
	| "long"	=> (BPT.T_Raw BPT.T_Long)
	;

FloatTy	: "float"	=> (BPT.T_Raw BPT.T_Float)
	| "double"	=> (BPT.T_Raw BPT.T_Double)
	;
