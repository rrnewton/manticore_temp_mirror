(* sum-ls-foldr.bom 
 * Given an integer i, create the list [i,..,1], and return the summation of
 * the list (using foldr).
 *)

module SumLsFoldr
  fun init (arg : any; exh : cont(any)) : unit =

    fun add (p : (int, int); exh : cont(any)) : int =
	let x : int = #0(p)
	let y : int = #1(p)
	return (I32Add (x, y))

    (* returns the list [i,..,1] *)
    fun tabulate (i : int; exh : cont(any)) : list =
	if I32Lte (i, 0:int) then return (enum(0))
	else let tl : list = apply tabulate (I32Sub (i, 1:int); exh)
	     return (CONS(i, tl))

    fun foldr (p : (fun((any,any); cont(any) -> int), list, any); exh : cont(any)) : any =
	let f : fun((any,any); cont(any) -> int) = #0(p)
	let ls : list = #1(p)
	let acc : any = #2(p)
	case ls 
	 of enum(0) => return (acc)
	  | CONS(hd : any, tl : list) =>
	      let a : (fun((any, any); cont(any) -> int), list, any) = alloc (f, tl, acc)
	      let a : any = (any)a
	      let b : any = apply foldr (a; exh)
	      let c : (any, any) = alloc (hd, b)
	      apply f (c; exh)
        end	      

    fun doit (i : int; exh : cont(any)) : int =
	let l : list = apply tabulate (i; exh)
	let a : (fun((int, int); cont(any) -> int), list, int) = alloc (add, l, 0)
	let a : any = (any)a
	let ls : any = apply foldr (a; exh)
	let ls : int = (int)ls
	return (ls)

    return (enum(0))
