(* switch.bom *)

module Switch
  extern void M_Print (void *);

  fun init (wi : [int]; exh : cont(any)) : any =
    let stop : enum(0) = 0
    let dummyTid : enum(0) = 0
    let limit : long = 1000000000

    let retVal : [int] = wrap(1:int)

    fun thread_exit (x : enum(0); exh : cont(any)) : any =
          do ccall M_Print ("thread exiting\n\000")
	  let vp : vproc = host_vproc
	    @forward (vp, stop)

    fun spawn (f : fun(enum(0); cont(any) -> enum(0)); exh : cont(any)) : enum(0) =
	  cont fiber (x : enum(0)) =
		do apply f (x; exh)
		apply thread_exit(enum(0); exh)
	  do @enqueue(host_vproc, dummyTid, fiber)
	  return (enum(0))

    fun loop (x : long; exh : cont(any)) : enum(0) =
	  if I64Eq(x, limit)
	    then return (enum(0))
	    else apply loop(I64Add(x, 1:long); exh)

    fun thread (arg : enum(0); exh : cont(any)) : enum(0) =
          do ccall M_Print ("thread starting\n\000")
	  apply loop (0:long; exh)

   (* action is a scheduler action that terminates upon a stop
    * signal, and resumes upon a preempt signal.
    *)
    cont action (sign : signal) =
	  let vp : vproc = host_vproc
	  case sign
	   of enum(0) =>
		do ccall M_Print ("handle STOP\n\000")
		let item : (any, cont(enum(0)), any) = @dequeue(vp)
		let nextFiber : cont(enum(0)) = #1(item)
		@run (vp, action, nextFiber)
	    | PREEMPT(fiber : cont(enum(0))) =>
		do ccall M_Print ("handle PREEMPT\n\000")
		do @enqueue(vp, enum(0), fiber)
		let item : (any, cont(enum(0)), any) = @dequeue(vp)
		let nextFiber : cont(enum(0)) = #1(item)
		@run (vp, action, nextFiber)
	  end

    cont fiber (x : any) =
	fun lp (i : int; exh : cont(any)) : any =
	      if I32Eq(i, 0:int)
		then apply thread_exit (enum(0); exh)
		else
		  do apply spawn(thread; exh)
		  apply lp(I32Sub(i, 1:int); exh)
	apply lp(4:int; exh)

  (* start the initial fiber *)
    let vp : vproc = host_vproc
    @run (vp, action, fiber)
