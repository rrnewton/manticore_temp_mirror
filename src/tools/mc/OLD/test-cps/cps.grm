(* cps.grm
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *)

%name CPS;

%tokens
    : KW_alloc		("alloc")
    | KW_and		("and")
    | KW_any		("any")
    | KW_apply		("apply")
    | KW_attribute	("__attribute__")
    | KW_bool		("bool")
    | KW_byte		("byte")
    | KW_case		("case")
    | KW_ccall		("ccall")
    | KW_cont		("cont")
    | KW_default	("default")
    | KW_do		("do")
    | KW_double		("double")
    | KW_else		("else")
    | KW_end		("end")
    | KW_enum		("enum")
    | KW_extern		("extern")
    | KW_float		("float")
    | KW_fun		("fun")
    | KW_host_vproc	("host_vproc")
    | KW_if		("if")
    | KW_int		("int")
    | KW_let		("let")
    | KW_long		("long")
    | KW_module		("module")
    | KW_pure		("pure")
    | KW_short		("short")
    | KW_switch		("switch")
    | KW_then		("then")
    | KW_throw		("throw")
    | KW_unit		("unit")
    | KW_unwrap		("unwrap")
    | KW_vec128		("vec128")
    | KW_void		("void")
    | KW_vproc		("vproc")
    | KW_wrap		("wrap")
    | LP		("(")
    | RP		(")")
    | LB		("[")
    | RB		("]")
    | HASH		("#")
    | STAR		("*")
    | COMMA		(",")
    | EQ		("=")
    | COLON		(":")
    | SEMI		(";")
    | ID of Atom.atom
    | INT of IntInf.int
    | FLOAT of FloatLit.float
    | STRING of string
    ;

%defs(
    structure PT = CPSPT
    structure CF = CFunctions

    fun flatten NONE = []
      | flatten (SOME(x, xs)) = x::xs
);


Module
	: "module" ID Import* "fun" Lambda
		=> (PT.MODULE{name=ID, externs=Import, body=Lambda})
	;

Import
	: "extern" CRetTy ID "(" (CArgTy ("," CArgTy)* )? ")" Attrs ";"
		=> (CF.CFun{
			var = ID,
			name = Atom.toString ID,
			retTy = CRetTy,
			argTys = flatten SR,
			attrs = Attrs
		      })
	;

CRetTy
	: "void"	=> (CF.VoidTy)
	| CArgTy	=> (CArgTy)
	;

CArgTy
	: RawType	=> (CF.BaseTy RawType)
	| "void" "*"	=> (CF.PointerTy)
	;

Attrs
	: (* empty *)	=> ([])
	| "__attribute__" "(" "(" Attr ("," Attr)* ")" ")"
		=> (Attr :: SR)
	;

Attr
	: "pure"	=> (CFunctions.A_pure)
	| "alloc"	=> (CFunctions.A_alloc)
	;

Lambda
	: ID "(" Params ";" Params ")" "=" Exp	=> (ID, Params1, Params2, Exp)
	;

CLambda
	: ID "(" Params ")" "=" Exp		=> (ID, Params, [], Exp)
	;

Params
	: (Param ("," Param)*)?			=> (flatten SR)
	;

Param
	: ID ":" Type	=> (ID, Type)
	;

Type
	: "any"					=> (PT.T_Any)
	| "bool"				=> (CPSTy.boolTy)
	| "unit"				=> (CPSTy.unitTy)
	| "enum" "(" INT ")"			=> (PT.T_Enum(Word.fromLargeInt INT))
	| "[" RawType "]"			=> (PT.T_Wrap RawType)
	| RawType				=> (PT.T_Raw RawType)
	| "(" Type ("," Type)* ")"		=> (PT.T_Tuple(false, Type :: SR))
	| "fun" "(" Types ";" Types ")"		=> (PT.T_Fun(Types1, Types2))
	| "cont" "(" Types ")"			=> (PT.T_Fun(Types, []))
	| "vproc"				=> (PT.T_VProc)
	;

Types
	: (Type ("," Type)* )?			=> (flatten SR)
	;

RawType
	: "byte"	=> (PT.T_Byte)
	| "short"	=> (PT.T_Short)
	| "int"		=> (PT.T_Int)
	| "long"	=> (PT.T_Long)
	| "float"	=> (PT.T_Float)
	| "double"	=> (PT.T_Double)
	| "vec128"	=> (PT.T_Vec128)
	;

Exp
	: "let" LHS "=" RHS Exp				=> (PT.Let(LHS, RHS, Exp))
	| "do" RHS Exp					=> (PT.Let([], RHS, Exp))
	| "fun" Lambda ("and" Lambda)* Exp		=> (PT.Fun(Lambda::SR, Exp))
	| "cont" CLambda Exp				=> (PT.Cont(CLambda, Exp))
	| "if" SimpleExp "then" Exp "else" Exp		=> (PT.If(SimpleExp, Exp1, Exp2))
	| "switch" SimpleExp Cases DefaultCase? "end"	=> (PT.Switch(SimpleExp, Cases, DefaultCase))
	| "apply" ID "(" ArgExps ";" ArgExps ")"	=> (PT.Apply(ID, ArgExps1, ArgExps2))
	| "throw" ID Args				=> (PT.Throw(ID, Args))
	;

LHS
	: Param			=> ([Param])
	| "(" Params ")"	=> (Params)
	;

RHS
	: SimpleExp			=> (PT.SimpleExp SimpleExp)
	| "alloc" Args			=> (PT.Alloc Args)
	| "wrap" "(" SimpleExp ")"	=> (PT.Wrap SimpleExp)
	| "ccall" ID Args		=> (PT.CCall(ID, Args))
	;

SimpleExp
	: ID				=> (PT.Var ID)
	| "#" INT "(" SimpleExp ")"	=> (PT.Select(Int.fromLarge INT, SimpleExp))
	| "unwrap" "(" SimpleExp ")"	=> (PT.Unwrap SimpleExp)
	| ID Args			=> (PT.Prim(ID, Args))
	| "(" Type ")" SimpleExp	=> (PT.Cast(Type, SimpleExp))
	| INT (":" RawType)?		=> (PT.Literal(Literal.Int INT, SR))
	| FLOAT (":" RawType)?		=> (PT.Literal(Literal.Float FLOAT, SR))
	| STRING			=> (PT.Literal(Literal.String STRING, NONE))
	| "host_vproc"			=> (PT.HostVProc)
	;

Args
	: "(" ArgExps ")"		=> (ArgExps)
	;

ArgExps
	: (SimpleExp ("," SimpleExp)* )?	=> (flatten SR)
	;

Cases
	: ("case" INT ":" Exp => (Int.fromLarge INT, Exp))+
	;

DefaultCase
	: "default" ":" Exp		=> (Exp)
	;
