(* hlrw-def.grm
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 *)

%name HLRWDef;

%tokens
        : KW_addr       ("addr")
        | KW_any        ("any")
        | KW_byte       ("byte")
        | KW_cont       ("cont")
        | KW_double     ("double")
        | KW_enum       ("enum")
        | KW_float      ("float")
        | KW_fun        ("fun")
        | KW_int        ("int")
        | KW_long       ("long")
        | KW_short      ("short")
        | KW_typedef    ("typedef")
        | KW_vec128     ("vec128")
        | KW_vproc      ("vproc")
        | LP            ("(")
        | RP            (")")
        | LB            ("[")
        | RB            ("]")
        | LBRKT         ("{")
        | RBRKT         ("}")
        | COLON         (":")
        | SEMI          (";")
        | COMMA         (",")
        | EQ            ("=")
        | BANG          ("!")
        | SLASH         ("/")
        | ARROW         ("->")
        | DDARROW       ("==>")
        | ID of Atom.atom
        | HLOP of Atom.atom
        | POSINT of IntInf.int
        | NEGINT of IntInf.int
        | FLOAT of FloatLit.float
        | STRING of string
        ;

%defs(

      val zero = IntInf.fromInt 0

      val label_counter = ref 0

      fun new_label () = let
          val ret_val = Atom.atom ("$rewrite" ^
                                   (Int.toString (!label_counter)))
      in
          label_counter := !label_counter + 1;
          ret_val
      end (* new_label() *)

      val dfltIntTy = HLRWDefPT.T_Raw(BOMTy.T_Int)
      val dfltFloatTy = HLRWDefPT.T_Raw(BOMTy.T_Float)
      val dfltStringTy = HLRWDefPT.T_Any (* FIXME *)

      fun flatten NONE = []
        | flatten (SOME(x, xs)) = x::xs

      val listTyTerm = HLRWDefPT.T_TyCon(Atom.atom "list")

      val nilPat = HLRWDefPT.Const((Literal.Enum(Word.fromInt 0), listTyTerm))

      fun listToDConList [] = nilPat
        | listToDConList (pat :: ps) = HLRWDefPT.Call(Atom.atom "CONS",
                                                      [pat, listToDConList ps])

);

File
        : Rewrite*
                => ( Rewrite : HLRWDefPT.file )
        ;

Rewrite
        : LabelOpt Pattern DDARROW Pattern Benefit ";"
                => ( HLRWDefPT.RewriteDef(
                         HLRWDefPT.Rewrite {label = LabelOpt,
                                            lhs = Pattern1,
                                            rhs = Pattern2,
                                            weight = Benefit}) )
        | "typedef" ID "=" Type ";"
                => ( HLRWDefPT.TypeDef(ID, Type) )
        ;

LabelOpt
        : (* empty *)
                => ( new_label () )
        | ID COLON
                => ( ID )
        ;

Pattern
        : IdOrHLOp LP PatternArgs RP
                => ( HLRWDefPT.Call(IdOrHLOp, PatternArgs) )

        | LB PatternArgs RB
                => ( listToDConList(PatternArgs) )

        | Literal
                => ( HLRWDefPT.Const(Literal) )

        | ID
                => ( HLRWDefPT.Var ID )
        ;

Literal
        : "enum" "(" POSINT ")" (":" Type)?
                => (let
                        val w = Word.fromLargeInt POSINT
                    in
                        case SR
                         of NONE => (Literal.Enum w, HLRWDefPT.T_Enum w)
                          | SOME ty => (Literal.Enum w, ty)
                        (* end case *)
                    end)

        (* XXX - Omitted: state values. *)

        | Int (":" Type)?
                => (let
                        val iLit = Literal.Int Int
                    in case SR
                        of NONE => (iLit, dfltIntTy)
                         | SOME ty => (iLit, ty)
                        (* end case *)
                    end)

        | FLOAT (":" Type)?
                => (let
                        val fLit = Literal.Float FLOAT
                    in case SR
                        of NONE => (fLit, dfltFloatTy)
                         | SOME ty => (fLit, dfltFloatTy)
                        (* end case *)
                    end)

        | STRING
                => (Literal.String STRING, dfltStringTy)

        ;

Int
        : POSINT => (POSINT)
        | NEGINT => (NEGINT)
        ;

Type
        : "addr" "(" Type ")"
                => (HLRWDefPT.T_Addr(Type))
        | "any"
                => (HLRWDefPT.T_Any)
        | "enum" "(" POSINT ")"
                => (HLRWDefPT.T_Enum(Word.fromLargeInt POSINT))
        | RawType
                => (HLRWDefPT.T_Raw RawType)
        | "!" "[" Type ("," Type)* "]"
                => (HLRWDefPT.T_Tuple(true, Type :: SR))
        | "[" Type ("," Type)* "]"
                => (HLRWDefPT.T_Tuple(false, Type :: SR))
        | "fun" "(" TypeList "/" TypeList "->" TypeList ")"
                => (HLRWDefPT.T_Fun(TypeList1, TypeList2, TypeList3))
        | "cont" "(" TypeList ")"
                => (HLRWDefPT.T_Cont TypeList)
        | "vproc"
                => (HLRWDefPT.T_VProc)
        | ID
                => (HLRWDefPT.T_TyCon ID)
        ;

TypeList
        : (Type ("," Type)* )?  => (flatten SR)
        ;

RawType
        : "byte"   => (HLRWDefPT.T_Byte)
        | "short"  => (HLRWDefPT.T_Short)
        | "int"    => (HLRWDefPT.T_Int)
        | "long"   => (HLRWDefPT.T_Long)
        | "float"  => (HLRWDefPT.T_Float)
        | "double" => (HLRWDefPT.T_Double)
        | "vec128" => (HLRWDefPT.T_Vec128)
        ;

PatternArgs
        : (* empty *)
                => ( [] )
        | Pattern (COMMA Pattern)*
                => ( Pattern :: SR )
        ;

Benefit
        : LBRKT POSINT RBRKT
                => ( POSINT )
        | LBRKT RBRKT
                => ( zero )
        | (* Empty *)
                => ( zero )
        ;

IdOrHLOp
        : ID
                => ( ID )
        | HLOP
                => ( HLOP )
        ;
