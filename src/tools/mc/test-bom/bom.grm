(* bom.grm
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *)

%name BOM;

%tokens
	: KW_addr	("addr")
	| KW_alloc	("alloc")
	| KW_and	("and")
	| KW_any	("any")
	| KW_apply	("apply")
	| KW_attribute	("__attribute__")
	| KW_bool	("bool")
	| KW_byte	("byte")
	| KW_case	("case")
	| KW_ccall	("ccall")
	| KW_cont	("cont")
	| KW_do		("do")   
	| KW_double	("double")
	| KW_else	("else")
	| KW_end	("end")
	| KW_enum	("enum")
	| KW_extern	("extern")
	| KW_float	("float")
	| KW_fun	("fun")
	| KW_galloc	("galloc")
	| KW_host_vproc ("host_vproc")
	| KW_if		("if")
	| KW_int	("int")
	| KW_let	("let")
	| KW_long	("long")
	| KW_module	("module")
	| KW_of		("of")
	| KW_promote	("promote")
	| KW_pure	("pure")
        | KW_return	("return")
	| KW_short	("short")
	| KW_then	("then")
	| KW_throw	("throw")
	| KW_unit	("unit")
	| KW_unwrap	("unwrap")
	| KW_vec128	("vec128")
	| KW_void	("void")
	| KW_vproc	("vproc")
	| KW_wrap	("wrap")
	| LP		("(")
	| RP		(")")
	| LB		("[")
	| RB		("]")
	| HASH		("#")
	| STAR		("*")
	| COMMA		(",")
	| EQ		("=")
	| COLON		(":")
	| SEMI		(";")
	| SLASH		("/")
	| BAR		("|")
	| WILD		("_")
	| BANG		("!")
	| AMP		("&")
	| ASSIGN	(":=")
	| DARROW	("=>")
	| ARROW		("->")
	| ID of Atom.atom
	| HLOP of Atom.atom
	| INT of IntInf.int
	| FLOAT of FloatLit.float
	| STRING of string
	;

%defs(
    structure PT = BOMPT
    structure CF = CFunctions

    fun flatten NONE = []
      | flatten (SOME(x, xs)) = x::xs

    val unitTy = PT.T_Enum(0w0)
    val boolTy = PT.T_Enum(0w1)	(* false = 0, true = 1 *)

  (* default types for literals *)
    val dfltIntTy = PT.T_Raw(BOMTy.T_Int)
    val dfltFloatTy = PT.T_Raw(BOMTy.T_Float)
    val dfltStringTy = PT.T_Any (* FIXME *)
);


Module
	: "module" ID Import* "fun" Lambda
		=> (PT.MODULE{name=ID, externs=Import, body=Lambda})
	;

Import
	: "extern" CRetTy ID "(" (CArgTy ("," CArgTy)* )? ")" Attrs ";"
		=> (CF.CFun{
			var = ID,
			name = Atom.toString ID,
			retTy = CRetTy,
			argTys = flatten SR,
			varArg = false,
			attrs = Attrs
		      })
	;

CRetTy
	: "void"	=> (CF.VoidTy)
	| CArgTy	=> (CArgTy)
	;

CArgTy
	: RawType	=> (CF.BaseTy RawType)
	| "void" "*"	=> (CF.PointerTy)
	;

Attrs
	: (* empty *)	=> ([])
	| "__attribute__" "(" "(" Attr ("," Attr)* ")" ")"
		=> (Attr :: SR)
	;

Attr
	: "pure"	=> (CFunctions.A_pure)
	| "alloc"	=> (CFunctions.A_alloc)
	;

Lambda
	: ID "(" Params ("/" Params)? ")" ":" FunReturnTy "=" Exp
		=> (ID, Params, Option.getOpt(SR, []), FunReturnTy, Exp)
	;

Params
	: (Param ("," Param)* )?		=> (flatten SR)
	;

Param
	: ID ":" Type				=> (ID, Type)
	;

FunReturnTy
	: Type			=> ([Type])
	| "(" TypeList ")"	=> (TypeList)
	;

CLambda
	: ID "(" Params ")" "=" Exp		=> (ID, Params, [], [], Exp)
	;

Type
	: "addr" "(" Type ")"			=> (PT.T_Addr(Type))
	| "any"					=> (PT.T_Any)
	| "bool"				=> (boolTy)
	| "unit"				=> (unitTy)
	| "enum" "(" INT ")"			=> (PT.T_Enum(Word.fromLargeInt INT))
	| RawType				=> (PT.T_Raw RawType)
	| "!" "[" Type ("," Type)* "]"		=> (PT.T_Tuple(true, Type :: SR))
	| "[" Type ("," Type)* "]"		=> (PT.T_Tuple(false, Type :: SR))
	| "fun" "(" TypeList "/" TypeList "->" TypeList ")"	=> (PT.T_Fun(TypeList1, TypeList2, TypeList3))
	| "cont" "(" TypeList ")"		=> (PT.T_Cont TypeList)
	| "vproc"				=> (PT.T_VProc)
	| ID					=> (PT.T_TyCon ID)
	;

TypeList
	: (Type ("," Type)* )?  => (flatten SR)
	;

RawType
	: "byte"	=> (PT.T_Byte)
	| "short"	=> (PT.T_Short)
	| "int"		=> (PT.T_Int)
	| "long"	=> (PT.T_Long)
	| "float"	=> (PT.T_Float)
	| "double"	=> (PT.T_Double)
	| "vec128"	=> (PT.T_Vec128)
	;

Exp
	: "let" LHS "=" RHS Exp				=> (PT.Let(LHS, RHS, Exp))
	| "do" RHS Exp					=> (PT.Let([], RHS, Exp))
	| "fun" Lambda ("and" Lambda)* Exp		=> (PT.Fun(Lambda::SR, Exp))
	| "cont" CLambda Exp				=> (PT.Cont(CLambda, Exp))
	| "if" SimpleExp "then" Exp "else" Exp		=> (PT.If(SimpleExp, Exp1, Exp2))
        | "case" SimpleExp "of" Rules ("|" Default)? "end"	=> (PT.Case(SimpleExp, Rules, SR))
	| "apply" ID "(" Args ("/" Args)? ")"		=> (PT.Apply(ID, Args, Option.getOpt(SR, [])))
	| "throw" ID "(" Args ")"			=> (PT.Throw(ID, Args))
	| "return" "(" Args ")"				=> (PT.Return Args)
	| HLOP "(" Args ("/" Args)? ")"
		=> (PT.HLOpApply(HLOP, Args, Option.getOpt(SR, [])))
	;

LHS
	: Param				=> ([Param])
	| "(" Params ")"		=> (Params)
	;

RHS
	: Exp				=> (PT.Exp Exp)
	| NonSelectExp			=> (PT.SimpleExp NonSelectExp)
	| "#" INT "(" SimpleExp ")" (":=" SimpleExp)?
		=> (case SR
		     of SOME e => PT.Update(Int.fromLarge INT, SimpleExp, e)
		      | NONE => PT.SimpleExp(PT.Select(Int.fromLarge INT, SimpleExp))
		    (* end case *))
	| "alloc" "(" Args ")"		=> (PT.Alloc Args)
	| "galloc" "(" Args ")"		=> (PT.GAlloc Args)
	| "promote" "(" SimpleExp ")"	=> (PT.Promote SimpleExp)
	| "wrap" "(" SimpleExp ")"	=> (PT.Wrap SimpleExp)
	| "ccall" ID "(" Args ")"	=> (PT.CCall(ID, Args))
	;

NonSelectExp
	: ID				=> (PT.Var ID)
	| "&" INT "(" SimpleExp ")"	=> (PT.AddrOf(Int.fromLarge INT, SimpleExp))
	| "unwrap" "(" SimpleExp ")"	=> (PT.Unwrap SimpleExp)
	| ID "(" Args ")"		=> (PT.Prim(ID, Args))
	| "(" Type ")" SimpleExp	=> (PT.Cast(Type, SimpleExp))
	| Literal			=> (PT.Const(Literal))
	| "host_vproc"			=> (PT.HostVProc)
	;

SimpleExp
	: NonSelectExp			=> (NonSelectExp)
	| "#" INT "(" SimpleExp ")"	=> (PT.Select(Int.fromLarge INT, SimpleExp))
	;

Args
	: (SimpleExp ("," SimpleExp)* )?	=> (flatten SR)
	;

Rules
	: Rule ("|" Rule)*		=> (Rule :: SR)
	;

Rule
	: ID "(" VarPat ("," VarPat)* ")" "=>" Exp
					=> (PT.DConPat(ID, VarPat::SR), Exp)
	| Literal "=>" Exp		=> (PT.ConstPat Literal, Exp)
	;

Default
	: VarPat "=>" Exp		=> (VarPat, Exp)
	;

VarPat
	: "_"				=> (PT.WildPat)
	| ID ":" Type			=> (PT.VarPat(ID, Type))
	;

Literal
	: "enum" "(" INT ")" (":" Type)?
		=> (let
		    val w = Word.fromLargeInt INT
		    in
		      case SR
		       of NONE => (Literal.Enum w, PT.T_Enum w)
			| SOME ty => (Literal.Enum w, ty)
		      (* end case *)
		    end)
	| INT (":" Type)?
		=> (case SR
		   of NONE => (Literal.Int INT, dfltIntTy)
		    | SOME ty => (Literal.Int INT, ty)
		  (* end case *))
	| FLOAT (":" Type)?
		=> (case SR
		   of NONE => (Literal.Float FLOAT, dfltFloatTy)
		    | SOME ty => (Literal.Float FLOAT, ty)
		  (* end case *))
	| STRING
		=> (Literal.String STRING, dfltStringTy)
	;
